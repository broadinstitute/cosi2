<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libsigc++: mem_fun()</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libsigc++
   &#160;<span id="projectnumber">2.3.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> </div>
  <div class="headertitle">
<div class="title">mem_fun()</div> </div>
<div class="ingroups"><a class="el" href="group__sigcfunctors.html">Functors</a></div></div><!--header-->
<div class="contents">

<p><a class="el" href="group__mem__fun.html#ga52244864d2f65f072678b682bfc9913f" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">mem_fun()</a> is used to convert a pointer to a method to a functor. <a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor0.html">sigc::mem_functor0&lt; T_return, T_obj &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor0.html" title="mem_functor0 wraps methods with 0 argument(s).">mem_functor0</a> wraps methods with 0 argument(s). <a href="classsigc_1_1mem__functor0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor1.html">sigc::mem_functor1&lt; T_return, T_obj, T_arg1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor1.html" title="mem_functor1 wraps methods with 1 argument(s).">mem_functor1</a> wraps methods with 1 argument(s). <a href="classsigc_1_1mem__functor1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor2.html">sigc::mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor2.html" title="mem_functor2 wraps methods with 2 argument(s).">mem_functor2</a> wraps methods with 2 argument(s). <a href="classsigc_1_1mem__functor2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor3.html">sigc::mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor3.html" title="mem_functor3 wraps methods with 3 argument(s).">mem_functor3</a> wraps methods with 3 argument(s). <a href="classsigc_1_1mem__functor3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor4.html">sigc::mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor4.html" title="mem_functor4 wraps methods with 4 argument(s).">mem_functor4</a> wraps methods with 4 argument(s). <a href="classsigc_1_1mem__functor4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor5.html">sigc::mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor5.html" title="mem_functor5 wraps methods with 5 argument(s).">mem_functor5</a> wraps methods with 5 argument(s). <a href="classsigc_1_1mem__functor5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor6.html">sigc::mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor6.html" title="mem_functor6 wraps methods with 6 argument(s).">mem_functor6</a> wraps methods with 6 argument(s). <a href="classsigc_1_1mem__functor6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor7.html">sigc::mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor7.html" title="mem_functor7 wraps methods with 7 argument(s).">mem_functor7</a> wraps methods with 7 argument(s). <a href="classsigc_1_1mem__functor7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor0.html">sigc::const_mem_functor0&lt; T_return, T_obj &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor0.html" title="const_mem_functor0 wraps const methods with 0 argument(s).">const_mem_functor0</a> wraps const methods with 0 argument(s). <a href="classsigc_1_1const__mem__functor0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor1.html">sigc::const_mem_functor1&lt; T_return, T_obj, T_arg1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor1.html" title="const_mem_functor1 wraps const methods with 1 argument(s).">const_mem_functor1</a> wraps const methods with 1 argument(s). <a href="classsigc_1_1const__mem__functor1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor2.html">sigc::const_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor2.html" title="const_mem_functor2 wraps const methods with 2 argument(s).">const_mem_functor2</a> wraps const methods with 2 argument(s). <a href="classsigc_1_1const__mem__functor2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor3.html">sigc::const_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor3.html" title="const_mem_functor3 wraps const methods with 3 argument(s).">const_mem_functor3</a> wraps const methods with 3 argument(s). <a href="classsigc_1_1const__mem__functor3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor4.html">sigc::const_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor4.html" title="const_mem_functor4 wraps const methods with 4 argument(s).">const_mem_functor4</a> wraps const methods with 4 argument(s). <a href="classsigc_1_1const__mem__functor4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor5.html">sigc::const_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor5.html" title="const_mem_functor5 wraps const methods with 5 argument(s).">const_mem_functor5</a> wraps const methods with 5 argument(s). <a href="classsigc_1_1const__mem__functor5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor6.html">sigc::const_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor6.html" title="const_mem_functor6 wraps const methods with 6 argument(s).">const_mem_functor6</a> wraps const methods with 6 argument(s). <a href="classsigc_1_1const__mem__functor6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor7.html">sigc::const_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor7.html" title="const_mem_functor7 wraps const methods with 7 argument(s).">const_mem_functor7</a> wraps const methods with 7 argument(s). <a href="classsigc_1_1const__mem__functor7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor0.html">sigc::volatile_mem_functor0&lt; T_return, T_obj &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor0.html" title="volatile_mem_functor0 wraps volatile methods with 0 argument(s).">volatile_mem_functor0</a> wraps volatile methods with 0 argument(s). <a href="classsigc_1_1volatile__mem__functor0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor1.html">sigc::volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor1.html" title="volatile_mem_functor1 wraps volatile methods with 1 argument(s).">volatile_mem_functor1</a> wraps volatile methods with 1 argument(s). <a href="classsigc_1_1volatile__mem__functor1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor2.html">sigc::volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor2.html" title="volatile_mem_functor2 wraps volatile methods with 2 argument(s).">volatile_mem_functor2</a> wraps volatile methods with 2 argument(s). <a href="classsigc_1_1volatile__mem__functor2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor3.html">sigc::volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor3.html" title="volatile_mem_functor3 wraps volatile methods with 3 argument(s).">volatile_mem_functor3</a> wraps volatile methods with 3 argument(s). <a href="classsigc_1_1volatile__mem__functor3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor4.html">sigc::volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor4.html" title="volatile_mem_functor4 wraps volatile methods with 4 argument(s).">volatile_mem_functor4</a> wraps volatile methods with 4 argument(s). <a href="classsigc_1_1volatile__mem__functor4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor5.html">sigc::volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor5.html" title="volatile_mem_functor5 wraps volatile methods with 5 argument(s).">volatile_mem_functor5</a> wraps volatile methods with 5 argument(s). <a href="classsigc_1_1volatile__mem__functor5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor6.html">sigc::volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor6.html" title="volatile_mem_functor6 wraps volatile methods with 6 argument(s).">volatile_mem_functor6</a> wraps volatile methods with 6 argument(s). <a href="classsigc_1_1volatile__mem__functor6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor7.html">sigc::volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor7.html" title="volatile_mem_functor7 wraps volatile methods with 7 argument(s).">volatile_mem_functor7</a> wraps volatile methods with 7 argument(s). <a href="classsigc_1_1volatile__mem__functor7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">sigc::const_volatile_mem_functor0&lt; T_return, T_obj &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor0.html" title="const_volatile_mem_functor0 wraps const volatile methods with 0 argument(s).">const_volatile_mem_functor0</a> wraps const volatile methods with 0 argument(s). <a href="classsigc_1_1const__volatile__mem__functor0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">sigc::const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor1.html" title="const_volatile_mem_functor1 wraps const volatile methods with 1 argument(s).">const_volatile_mem_functor1</a> wraps const volatile methods with 1 argument(s). <a href="classsigc_1_1const__volatile__mem__functor1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">sigc::const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor2.html" title="const_volatile_mem_functor2 wraps const volatile methods with 2 argument(s).">const_volatile_mem_functor2</a> wraps const volatile methods with 2 argument(s). <a href="classsigc_1_1const__volatile__mem__functor2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">sigc::const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor3.html" title="const_volatile_mem_functor3 wraps const volatile methods with 3 argument(s).">const_volatile_mem_functor3</a> wraps const volatile methods with 3 argument(s). <a href="classsigc_1_1const__volatile__mem__functor3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">sigc::const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor4.html" title="const_volatile_mem_functor4 wraps const volatile methods with 4 argument(s).">const_volatile_mem_functor4</a> wraps const volatile methods with 4 argument(s). <a href="classsigc_1_1const__volatile__mem__functor4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">sigc::const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor5.html" title="const_volatile_mem_functor5 wraps const volatile methods with 5 argument(s).">const_volatile_mem_functor5</a> wraps const volatile methods with 5 argument(s). <a href="classsigc_1_1const__volatile__mem__functor5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">sigc::const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor6.html" title="const_volatile_mem_functor6 wraps const volatile methods with 6 argument(s).">const_volatile_mem_functor6</a> wraps const volatile methods with 6 argument(s). <a href="classsigc_1_1const__volatile__mem__functor6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">sigc::const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor7.html" title="const_volatile_mem_functor7 wraps const volatile methods with 7 argument(s).">const_volatile_mem_functor7</a> wraps const volatile methods with 7 argument(s). <a href="classsigc_1_1const__volatile__mem__functor7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor0.html">sigc::bound_mem_functor0&lt; T_return, T_obj &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance.">bound_mem_functor0</a> encapsulates a method with 0 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor1.html">sigc::bound_mem_functor1&lt; T_return, T_obj, T_arg1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance.">bound_mem_functor1</a> encapsulates a method with 1 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor2.html">sigc::bound_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance.">bound_mem_functor2</a> encapsulates a method with 2 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor3.html">sigc::bound_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance.">bound_mem_functor3</a> encapsulates a method with 3 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor4.html">sigc::bound_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance.">bound_mem_functor4</a> encapsulates a method with 4 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor5.html">sigc::bound_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance.">bound_mem_functor5</a> encapsulates a method with 5 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor6.html">sigc::bound_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance.">bound_mem_functor6</a> encapsulates a method with 6 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor7.html">sigc::bound_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance.">bound_mem_functor7</a> encapsulates a method with 7 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html">sigc::bound_const_mem_functor0&lt; T_return, T_obj &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html" title="bound_const_mem_functor0 encapsulates a const method with 0 arguments and an object instance...">bound_const_mem_functor0</a> encapsulates a const method with 0 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html">sigc::bound_const_mem_functor1&lt; T_return, T_obj, T_arg1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html" title="bound_const_mem_functor1 encapsulates a const method with 1 arguments and an object instance...">bound_const_mem_functor1</a> encapsulates a const method with 1 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html">sigc::bound_const_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html" title="bound_const_mem_functor2 encapsulates a const method with 2 arguments and an object instance...">bound_const_mem_functor2</a> encapsulates a const method with 2 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html">sigc::bound_const_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html" title="bound_const_mem_functor3 encapsulates a const method with 3 arguments and an object instance...">bound_const_mem_functor3</a> encapsulates a const method with 3 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html">sigc::bound_const_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html" title="bound_const_mem_functor4 encapsulates a const method with 4 arguments and an object instance...">bound_const_mem_functor4</a> encapsulates a const method with 4 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html">sigc::bound_const_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html" title="bound_const_mem_functor5 encapsulates a const method with 5 arguments and an object instance...">bound_const_mem_functor5</a> encapsulates a const method with 5 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html">sigc::bound_const_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html" title="bound_const_mem_functor6 encapsulates a const method with 6 arguments and an object instance...">bound_const_mem_functor6</a> encapsulates a const method with 6 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html">sigc::bound_const_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html" title="bound_const_mem_functor7 encapsulates a const method with 7 arguments and an object instance...">bound_const_mem_functor7</a> encapsulates a const method with 7 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">sigc::bound_volatile_mem_functor0&lt; T_return, T_obj &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html" title="bound_volatile_mem_functor0 encapsulates a volatile method with 0 arguments and an object instance...">bound_volatile_mem_functor0</a> encapsulates a volatile method with 0 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">sigc::bound_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html" title="bound_volatile_mem_functor1 encapsulates a volatile method with 1 arguments and an object instance...">bound_volatile_mem_functor1</a> encapsulates a volatile method with 1 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">sigc::bound_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html" title="bound_volatile_mem_functor2 encapsulates a volatile method with 2 arguments and an object instance...">bound_volatile_mem_functor2</a> encapsulates a volatile method with 2 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">sigc::bound_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html" title="bound_volatile_mem_functor3 encapsulates a volatile method with 3 arguments and an object instance...">bound_volatile_mem_functor3</a> encapsulates a volatile method with 3 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">sigc::bound_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html" title="bound_volatile_mem_functor4 encapsulates a volatile method with 4 arguments and an object instance...">bound_volatile_mem_functor4</a> encapsulates a volatile method with 4 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">sigc::bound_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html" title="bound_volatile_mem_functor5 encapsulates a volatile method with 5 arguments and an object instance...">bound_volatile_mem_functor5</a> encapsulates a volatile method with 5 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">sigc::bound_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html" title="bound_volatile_mem_functor6 encapsulates a volatile method with 6 arguments and an object instance...">bound_volatile_mem_functor6</a> encapsulates a volatile method with 6 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">sigc::bound_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html" title="bound_volatile_mem_functor7 encapsulates a volatile method with 7 arguments and an object instance...">bound_volatile_mem_functor7</a> encapsulates a volatile method with 7 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">sigc::bound_const_volatile_mem_functor0&lt; T_return, T_obj &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html" title="bound_const_volatile_mem_functor0 encapsulates a const volatile method with 0 arguments and an object...">bound_const_volatile_mem_functor0</a> encapsulates a const volatile method with 0 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">sigc::bound_const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html" title="bound_const_volatile_mem_functor1 encapsulates a const volatile method with 1 arguments and an object...">bound_const_volatile_mem_functor1</a> encapsulates a const volatile method with 1 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">sigc::bound_const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html" title="bound_const_volatile_mem_functor2 encapsulates a const volatile method with 2 arguments and an object...">bound_const_volatile_mem_functor2</a> encapsulates a const volatile method with 2 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">sigc::bound_const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html" title="bound_const_volatile_mem_functor3 encapsulates a const volatile method with 3 arguments and an object...">bound_const_volatile_mem_functor3</a> encapsulates a const volatile method with 3 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">sigc::bound_const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html" title="bound_const_volatile_mem_functor4 encapsulates a const volatile method with 4 arguments and an object...">bound_const_volatile_mem_functor4</a> encapsulates a const volatile method with 4 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">sigc::bound_const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html" title="bound_const_volatile_mem_functor5 encapsulates a const volatile method with 5 arguments and an object...">bound_const_volatile_mem_functor5</a> encapsulates a const volatile method with 5 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">sigc::bound_const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html" title="bound_const_volatile_mem_functor6 encapsulates a const volatile method with 6 arguments and an object...">bound_const_volatile_mem_functor6</a> encapsulates a const volatile method with 6 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">sigc::bound_const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html" title="bound_const_volatile_mem_functor7 encapsulates a const volatile method with 7 arguments and an object...">bound_const_volatile_mem_functor7</a> encapsulates a const volatile method with 7 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gabd5e9a64995f5ca0f7895278a9ece6d6"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gabd5e9a64995f5ca0f7895278a9ece6d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gabd5e9a64995f5ca0f7895278a9ece6d6">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor0&lt; T_return, T_obj &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gabd5e9a64995f5ca0f7895278a9ece6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#gabd5e9a64995f5ca0f7895278a9ece6d6"></a><br/></td></tr>
<tr class="separator:gabd5e9a64995f5ca0f7895278a9ece6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a18696f671f364cfffb30f0e9611428"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr class="memitem:ga1a18696f671f364cfffb30f0e9611428"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga1a18696f671f364cfffb30f0e9611428">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor1&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga1a18696f671f364cfffb30f0e9611428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga1a18696f671f364cfffb30f0e9611428"></a><br/></td></tr>
<tr class="separator:ga1a18696f671f364cfffb30f0e9611428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63da7ee0d100b9e60613617cbd199a8d"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:ga63da7ee0d100b9e60613617cbd199a8d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga63da7ee0d100b9e60613617cbd199a8d">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga63da7ee0d100b9e60613617cbd199a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga63da7ee0d100b9e60613617cbd199a8d"></a><br/></td></tr>
<tr class="separator:ga63da7ee0d100b9e60613617cbd199a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf7482b0f9a6ea8426f5f1a108ed5539"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr class="memitem:gacf7482b0f9a6ea8426f5f1a108ed5539"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gacf7482b0f9a6ea8426f5f1a108ed5539">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gacf7482b0f9a6ea8426f5f1a108ed5539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#gacf7482b0f9a6ea8426f5f1a108ed5539"></a><br/></td></tr>
<tr class="separator:gacf7482b0f9a6ea8426f5f1a108ed5539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab85f8b77cba0d3928de62029c8f039e9"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr class="memitem:gab85f8b77cba0d3928de62029c8f039e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gab85f8b77cba0d3928de62029c8f039e9">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gab85f8b77cba0d3928de62029c8f039e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#gab85f8b77cba0d3928de62029c8f039e9"></a><br/></td></tr>
<tr class="separator:gab85f8b77cba0d3928de62029c8f039e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4d37bcfcf202f48a11e55cb6baadd6f"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr class="memitem:gab4d37bcfcf202f48a11e55cb6baadd6f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gab4d37bcfcf202f48a11e55cb6baadd6f">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gab4d37bcfcf202f48a11e55cb6baadd6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#gab4d37bcfcf202f48a11e55cb6baadd6f"></a><br/></td></tr>
<tr class="separator:gab4d37bcfcf202f48a11e55cb6baadd6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ef9a586816c1016e6c8f7b325301ab7"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr class="memitem:ga6ef9a586816c1016e6c8f7b325301ab7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga6ef9a586816c1016e6c8f7b325301ab7">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga6ef9a586816c1016e6c8f7b325301ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga6ef9a586816c1016e6c8f7b325301ab7"></a><br/></td></tr>
<tr class="separator:ga6ef9a586816c1016e6c8f7b325301ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga468e79dd7be56de4a3837b4c5fdde8ca"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr class="memitem:ga468e79dd7be56de4a3837b4c5fdde8ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga468e79dd7be56de4a3837b4c5fdde8ca">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga468e79dd7be56de4a3837b4c5fdde8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga468e79dd7be56de4a3837b4c5fdde8ca"></a><br/></td></tr>
<tr class="separator:ga468e79dd7be56de4a3837b4c5fdde8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c8e3d85a311ed8946447533b70d0d46"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga7c8e3d85a311ed8946447533b70d0d46"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga7c8e3d85a311ed8946447533b70d0d46">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor0&lt; T_return, T_obj &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga7c8e3d85a311ed8946447533b70d0d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga7c8e3d85a311ed8946447533b70d0d46"></a><br/></td></tr>
<tr class="separator:ga7c8e3d85a311ed8946447533b70d0d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee2a3da2684f1bcf2f53c7827c966867"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr class="memitem:gaee2a3da2684f1bcf2f53c7827c966867"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaee2a3da2684f1bcf2f53c7827c966867">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor1&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gaee2a3da2684f1bcf2f53c7827c966867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#gaee2a3da2684f1bcf2f53c7827c966867"></a><br/></td></tr>
<tr class="separator:gaee2a3da2684f1bcf2f53c7827c966867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec056e796fa861129436436d39aed604"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:gaec056e796fa861129436436d39aed604"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaec056e796fa861129436436d39aed604">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gaec056e796fa861129436436d39aed604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#gaec056e796fa861129436436d39aed604"></a><br/></td></tr>
<tr class="separator:gaec056e796fa861129436436d39aed604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79e40b784e00b7c442dcf7e5dba0e7d3"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr class="memitem:ga79e40b784e00b7c442dcf7e5dba0e7d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga79e40b784e00b7c442dcf7e5dba0e7d3">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga79e40b784e00b7c442dcf7e5dba0e7d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga79e40b784e00b7c442dcf7e5dba0e7d3"></a><br/></td></tr>
<tr class="separator:ga79e40b784e00b7c442dcf7e5dba0e7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf6f7626e673513f7a8850b4f3dd002f"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr class="memitem:gacf6f7626e673513f7a8850b4f3dd002f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gacf6f7626e673513f7a8850b4f3dd002f">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gacf6f7626e673513f7a8850b4f3dd002f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#gacf6f7626e673513f7a8850b4f3dd002f"></a><br/></td></tr>
<tr class="separator:gacf6f7626e673513f7a8850b4f3dd002f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga400f9f2d5b8f8ae4c3efd5291d8c278d"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr class="memitem:ga400f9f2d5b8f8ae4c3efd5291d8c278d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga400f9f2d5b8f8ae4c3efd5291d8c278d">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga400f9f2d5b8f8ae4c3efd5291d8c278d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga400f9f2d5b8f8ae4c3efd5291d8c278d"></a><br/></td></tr>
<tr class="separator:ga400f9f2d5b8f8ae4c3efd5291d8c278d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef07c518bd60eb9565c9091ec322476d"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr class="memitem:gaef07c518bd60eb9565c9091ec322476d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaef07c518bd60eb9565c9091ec322476d">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gaef07c518bd60eb9565c9091ec322476d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#gaef07c518bd60eb9565c9091ec322476d"></a><br/></td></tr>
<tr class="separator:gaef07c518bd60eb9565c9091ec322476d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga054db7e62e3f4cdc1a43c1c7023df7de"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr class="memitem:ga054db7e62e3f4cdc1a43c1c7023df7de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga054db7e62e3f4cdc1a43c1c7023df7de">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga054db7e62e3f4cdc1a43c1c7023df7de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga054db7e62e3f4cdc1a43c1c7023df7de"></a><br/></td></tr>
<tr class="separator:ga054db7e62e3f4cdc1a43c1c7023df7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9778e745dd100d983c7914229bd2560d"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga9778e745dd100d983c7914229bd2560d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga9778e745dd100d983c7914229bd2560d">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor0&lt; T_return, T_obj &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga9778e745dd100d983c7914229bd2560d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga9778e745dd100d983c7914229bd2560d"></a><br/></td></tr>
<tr class="separator:ga9778e745dd100d983c7914229bd2560d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3de3496749fd7647a85bcf376a4a832f"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr class="memitem:ga3de3496749fd7647a85bcf376a4a832f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga3de3496749fd7647a85bcf376a4a832f">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga3de3496749fd7647a85bcf376a4a832f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga3de3496749fd7647a85bcf376a4a832f"></a><br/></td></tr>
<tr class="separator:ga3de3496749fd7647a85bcf376a4a832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga469cf869c605b8ecf50fc31113dab706"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:ga469cf869c605b8ecf50fc31113dab706"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga469cf869c605b8ecf50fc31113dab706">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga469cf869c605b8ecf50fc31113dab706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga469cf869c605b8ecf50fc31113dab706"></a><br/></td></tr>
<tr class="separator:ga469cf869c605b8ecf50fc31113dab706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacab6d2c64c56e650d180005a3170bb19"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr class="memitem:gacab6d2c64c56e650d180005a3170bb19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gacab6d2c64c56e650d180005a3170bb19">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gacab6d2c64c56e650d180005a3170bb19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#gacab6d2c64c56e650d180005a3170bb19"></a><br/></td></tr>
<tr class="separator:gacab6d2c64c56e650d180005a3170bb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8b3078b7d2f36a4b82e09030e2cfa5a"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr class="memitem:gaf8b3078b7d2f36a4b82e09030e2cfa5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaf8b3078b7d2f36a4b82e09030e2cfa5a">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gaf8b3078b7d2f36a4b82e09030e2cfa5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#gaf8b3078b7d2f36a4b82e09030e2cfa5a"></a><br/></td></tr>
<tr class="separator:gaf8b3078b7d2f36a4b82e09030e2cfa5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb81af568daf632e59e2aeeb073956b5"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr class="memitem:gabb81af568daf632e59e2aeeb073956b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gabb81af568daf632e59e2aeeb073956b5">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gabb81af568daf632e59e2aeeb073956b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#gabb81af568daf632e59e2aeeb073956b5"></a><br/></td></tr>
<tr class="separator:gabb81af568daf632e59e2aeeb073956b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbb697f9fbf040c76368f2a1d778ea7d"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr class="memitem:gadbb697f9fbf040c76368f2a1d778ea7d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gadbb697f9fbf040c76368f2a1d778ea7d">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gadbb697f9fbf040c76368f2a1d778ea7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#gadbb697f9fbf040c76368f2a1d778ea7d"></a><br/></td></tr>
<tr class="separator:gadbb697f9fbf040c76368f2a1d778ea7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0514c3e40acd841d5e9c4ae4b774ded6"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr class="memitem:ga0514c3e40acd841d5e9c4ae4b774ded6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga0514c3e40acd841d5e9c4ae4b774ded6">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga0514c3e40acd841d5e9c4ae4b774ded6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga0514c3e40acd841d5e9c4ae4b774ded6"></a><br/></td></tr>
<tr class="separator:ga0514c3e40acd841d5e9c4ae4b774ded6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca854f6453dccd4a47f36721ddd3965e"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gaca854f6453dccd4a47f36721ddd3965e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaca854f6453dccd4a47f36721ddd3965e">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor0&lt; T_return, T_obj &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gaca854f6453dccd4a47f36721ddd3965e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#gaca854f6453dccd4a47f36721ddd3965e"></a><br/></td></tr>
<tr class="separator:gaca854f6453dccd4a47f36721ddd3965e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c0d65b88a0259e34437f0d0ea322251"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr class="memitem:ga4c0d65b88a0259e34437f0d0ea322251"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga4c0d65b88a0259e34437f0d0ea322251">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga4c0d65b88a0259e34437f0d0ea322251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga4c0d65b88a0259e34437f0d0ea322251"></a><br/></td></tr>
<tr class="separator:ga4c0d65b88a0259e34437f0d0ea322251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae260215430ab2b1ca8b80c40f5d0be00"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:gae260215430ab2b1ca8b80c40f5d0be00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gae260215430ab2b1ca8b80c40f5d0be00">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gae260215430ab2b1ca8b80c40f5d0be00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#gae260215430ab2b1ca8b80c40f5d0be00"></a><br/></td></tr>
<tr class="separator:gae260215430ab2b1ca8b80c40f5d0be00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3968c8eb9d73ea876c6b312d73e2c4a2"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr class="memitem:ga3968c8eb9d73ea876c6b312d73e2c4a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga3968c8eb9d73ea876c6b312d73e2c4a2">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga3968c8eb9d73ea876c6b312d73e2c4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga3968c8eb9d73ea876c6b312d73e2c4a2"></a><br/></td></tr>
<tr class="separator:ga3968c8eb9d73ea876c6b312d73e2c4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabed5fa33913a8234f792d31743004c42"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr class="memitem:gabed5fa33913a8234f792d31743004c42"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gabed5fa33913a8234f792d31743004c42">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gabed5fa33913a8234f792d31743004c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#gabed5fa33913a8234f792d31743004c42"></a><br/></td></tr>
<tr class="separator:gabed5fa33913a8234f792d31743004c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75a3dcba51260d7502ec923e8c0be5c6"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr class="memitem:ga75a3dcba51260d7502ec923e8c0be5c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga75a3dcba51260d7502ec923e8c0be5c6">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga75a3dcba51260d7502ec923e8c0be5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga75a3dcba51260d7502ec923e8c0be5c6"></a><br/></td></tr>
<tr class="separator:ga75a3dcba51260d7502ec923e8c0be5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3eee29bbfdb0fe95e0d31f32defb4b96"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr class="memitem:ga3eee29bbfdb0fe95e0d31f32defb4b96"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga3eee29bbfdb0fe95e0d31f32defb4b96">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga3eee29bbfdb0fe95e0d31f32defb4b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga3eee29bbfdb0fe95e0d31f32defb4b96"></a><br/></td></tr>
<tr class="separator:ga3eee29bbfdb0fe95e0d31f32defb4b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a0d4084f93bd2b1fcf95a5b495c4427"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr class="memitem:ga6a0d4084f93bd2b1fcf95a5b495c4427"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga6a0d4084f93bd2b1fcf95a5b495c4427">sigc::visit_each</a> (const T_action&amp; _A_action, const bound_const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga6a0d4084f93bd2b1fcf95a5b495c4427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="#ga6a0d4084f93bd2b1fcf95a5b495c4427"></a><br/></td></tr>
<tr class="separator:ga6a0d4084f93bd2b1fcf95a5b495c4427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54eb73c592288db072ae8fdcd0271809"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga54eb73c592288db072ae8fdcd0271809"><td class="memTemplItemLeft" align="right" valign="top">mem_functor0&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga54eb73c592288db072ae8fdcd0271809">sigc::mem_fun0</a> (T_return(T_obj::* _A_func)())</td></tr>
<tr class="memdesc:ga54eb73c592288db072ae8fdcd0271809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor0.html" title="mem_functor0 wraps methods with 0 argument(s).">sigc::mem_functor0</a> which wraps a method. <a href="#ga54eb73c592288db072ae8fdcd0271809"></a><br/></td></tr>
<tr class="separator:ga54eb73c592288db072ae8fdcd0271809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa89ed057c5d4a3fe7725f36840c2663"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gafa89ed057c5d4a3fe7725f36840c2663"><td class="memTemplItemLeft" align="right" valign="top">mem_functor1&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gafa89ed057c5d4a3fe7725f36840c2663">sigc::mem_fun1</a> (T_return(T_obj::* _A_func)(T_arg1))</td></tr>
<tr class="memdesc:gafa89ed057c5d4a3fe7725f36840c2663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor1.html" title="mem_functor1 wraps methods with 1 argument(s).">sigc::mem_functor1</a> which wraps a method. <a href="#gafa89ed057c5d4a3fe7725f36840c2663"></a><br/></td></tr>
<tr class="separator:gafa89ed057c5d4a3fe7725f36840c2663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae58a6e612c3ddc06be3a23c261636442"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gae58a6e612c3ddc06be3a23c261636442"><td class="memTemplItemLeft" align="right" valign="top">mem_functor2&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gae58a6e612c3ddc06be3a23c261636442">sigc::mem_fun2</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr class="memdesc:gae58a6e612c3ddc06be3a23c261636442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor2.html" title="mem_functor2 wraps methods with 2 argument(s).">sigc::mem_functor2</a> which wraps a method. <a href="#gae58a6e612c3ddc06be3a23c261636442"></a><br/></td></tr>
<tr class="separator:gae58a6e612c3ddc06be3a23c261636442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf8d584369e2c7d7b3cfea0ad6094a08"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gabf8d584369e2c7d7b3cfea0ad6094a08"><td class="memTemplItemLeft" align="right" valign="top">mem_functor3&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gabf8d584369e2c7d7b3cfea0ad6094a08">sigc::mem_fun3</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr class="memdesc:gabf8d584369e2c7d7b3cfea0ad6094a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor3.html" title="mem_functor3 wraps methods with 3 argument(s).">sigc::mem_functor3</a> which wraps a method. <a href="#gabf8d584369e2c7d7b3cfea0ad6094a08"></a><br/></td></tr>
<tr class="separator:gabf8d584369e2c7d7b3cfea0ad6094a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef2aecfa6f95d7b5fdb3b9d2b43dad23"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gaef2aecfa6f95d7b5fdb3b9d2b43dad23"><td class="memTemplItemLeft" align="right" valign="top">mem_functor4&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaef2aecfa6f95d7b5fdb3b9d2b43dad23">sigc::mem_fun4</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr class="memdesc:gaef2aecfa6f95d7b5fdb3b9d2b43dad23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor4.html" title="mem_functor4 wraps methods with 4 argument(s).">sigc::mem_functor4</a> which wraps a method. <a href="#gaef2aecfa6f95d7b5fdb3b9d2b43dad23"></a><br/></td></tr>
<tr class="separator:gaef2aecfa6f95d7b5fdb3b9d2b43dad23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b15cb11f5ecd0806f391f0e88a3c92a"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga8b15cb11f5ecd0806f391f0e88a3c92a"><td class="memTemplItemLeft" align="right" valign="top">mem_functor5&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga8b15cb11f5ecd0806f391f0e88a3c92a">sigc::mem_fun5</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr class="memdesc:ga8b15cb11f5ecd0806f391f0e88a3c92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor5.html" title="mem_functor5 wraps methods with 5 argument(s).">sigc::mem_functor5</a> which wraps a method. <a href="#ga8b15cb11f5ecd0806f391f0e88a3c92a"></a><br/></td></tr>
<tr class="separator:ga8b15cb11f5ecd0806f391f0e88a3c92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6705d585efb6c716ddb71c3eb0b0987c"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga6705d585efb6c716ddb71c3eb0b0987c"><td class="memTemplItemLeft" align="right" valign="top">mem_functor6&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga6705d585efb6c716ddb71c3eb0b0987c">sigc::mem_fun6</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr class="memdesc:ga6705d585efb6c716ddb71c3eb0b0987c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor6.html" title="mem_functor6 wraps methods with 6 argument(s).">sigc::mem_functor6</a> which wraps a method. <a href="#ga6705d585efb6c716ddb71c3eb0b0987c"></a><br/></td></tr>
<tr class="separator:ga6705d585efb6c716ddb71c3eb0b0987c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac74d8545aaf4999fe944157aef43ee30"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gac74d8545aaf4999fe944157aef43ee30"><td class="memTemplItemLeft" align="right" valign="top">mem_functor7&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gac74d8545aaf4999fe944157aef43ee30">sigc::mem_fun7</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr class="memdesc:gac74d8545aaf4999fe944157aef43ee30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor7.html" title="mem_functor7 wraps methods with 7 argument(s).">sigc::mem_functor7</a> which wraps a method. <a href="#gac74d8545aaf4999fe944157aef43ee30"></a><br/></td></tr>
<tr class="separator:gac74d8545aaf4999fe944157aef43ee30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d417e21d7f2da74454e2b6cbd8e136d"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga7d417e21d7f2da74454e2b6cbd8e136d"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor0&lt; T_return, <br class="typebreak"/>
T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga7d417e21d7f2da74454e2b6cbd8e136d">sigc::mem_fun0</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)())</td></tr>
<tr class="memdesc:ga7d417e21d7f2da74454e2b6cbd8e136d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance.">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance. <a href="#ga7d417e21d7f2da74454e2b6cbd8e136d"></a><br/></td></tr>
<tr class="separator:ga7d417e21d7f2da74454e2b6cbd8e136d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32580882b3288eb20b75a8c886a2e082"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga32580882b3288eb20b75a8c886a2e082"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor0&lt; T_return, <br class="typebreak"/>
T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga32580882b3288eb20b75a8c886a2e082">sigc::mem_fun0</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)())</td></tr>
<tr class="memdesc:ga32580882b3288eb20b75a8c886a2e082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance.">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance. <a href="#ga32580882b3288eb20b75a8c886a2e082"></a><br/></td></tr>
<tr class="separator:ga32580882b3288eb20b75a8c886a2e082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf1d0a1f044abdc784aa4fbcf9b827bf"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gadf1d0a1f044abdc784aa4fbcf9b827bf"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor1&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gadf1d0a1f044abdc784aa4fbcf9b827bf">sigc::mem_fun1</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>
<tr class="memdesc:gadf1d0a1f044abdc784aa4fbcf9b827bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance.">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance. <a href="#gadf1d0a1f044abdc784aa4fbcf9b827bf"></a><br/></td></tr>
<tr class="separator:gadf1d0a1f044abdc784aa4fbcf9b827bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab06ac23be30f9440af97b816e66cac06"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gab06ac23be30f9440af97b816e66cac06"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor1&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gab06ac23be30f9440af97b816e66cac06">sigc::mem_fun1</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>
<tr class="memdesc:gab06ac23be30f9440af97b816e66cac06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance.">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance. <a href="#gab06ac23be30f9440af97b816e66cac06"></a><br/></td></tr>
<tr class="separator:gab06ac23be30f9440af97b816e66cac06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78bc4c78ef14d8b7adcb7cfcfc098516"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga78bc4c78ef14d8b7adcb7cfcfc098516"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor2&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga78bc4c78ef14d8b7adcb7cfcfc098516">sigc::mem_fun2</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr class="memdesc:ga78bc4c78ef14d8b7adcb7cfcfc098516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance.">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance. <a href="#ga78bc4c78ef14d8b7adcb7cfcfc098516"></a><br/></td></tr>
<tr class="separator:ga78bc4c78ef14d8b7adcb7cfcfc098516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae5eb7ef1e372250026726f7b7ed3855"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaae5eb7ef1e372250026726f7b7ed3855"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor2&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaae5eb7ef1e372250026726f7b7ed3855">sigc::mem_fun2</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr class="memdesc:gaae5eb7ef1e372250026726f7b7ed3855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance.">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance. <a href="#gaae5eb7ef1e372250026726f7b7ed3855"></a><br/></td></tr>
<tr class="separator:gaae5eb7ef1e372250026726f7b7ed3855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dd21580bac297f5c524a61de335ff1d"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga2dd21580bac297f5c524a61de335ff1d"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor3&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga2dd21580bac297f5c524a61de335ff1d">sigc::mem_fun3</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr class="memdesc:ga2dd21580bac297f5c524a61de335ff1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance.">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance. <a href="#ga2dd21580bac297f5c524a61de335ff1d"></a><br/></td></tr>
<tr class="separator:ga2dd21580bac297f5c524a61de335ff1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade548b8b0e42109cfa9c798e185649b6"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gade548b8b0e42109cfa9c798e185649b6"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor3&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gade548b8b0e42109cfa9c798e185649b6">sigc::mem_fun3</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr class="memdesc:gade548b8b0e42109cfa9c798e185649b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance.">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance. <a href="#gade548b8b0e42109cfa9c798e185649b6"></a><br/></td></tr>
<tr class="separator:gade548b8b0e42109cfa9c798e185649b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b4680747cc51964f04827b1febfe8fa"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga3b4680747cc51964f04827b1febfe8fa"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor4&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga3b4680747cc51964f04827b1febfe8fa">sigc::mem_fun4</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr class="memdesc:ga3b4680747cc51964f04827b1febfe8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance.">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance. <a href="#ga3b4680747cc51964f04827b1febfe8fa"></a><br/></td></tr>
<tr class="separator:ga3b4680747cc51964f04827b1febfe8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05a5dce6cbcfd3947857c3f2dd62699c"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga05a5dce6cbcfd3947857c3f2dd62699c"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor4&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga05a5dce6cbcfd3947857c3f2dd62699c">sigc::mem_fun4</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr class="memdesc:ga05a5dce6cbcfd3947857c3f2dd62699c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance.">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance. <a href="#ga05a5dce6cbcfd3947857c3f2dd62699c"></a><br/></td></tr>
<tr class="separator:ga05a5dce6cbcfd3947857c3f2dd62699c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d2a08cc944e1dbb020eadbc0de96508"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga2d2a08cc944e1dbb020eadbc0de96508"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor5&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga2d2a08cc944e1dbb020eadbc0de96508">sigc::mem_fun5</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr class="memdesc:ga2d2a08cc944e1dbb020eadbc0de96508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance.">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance. <a href="#ga2d2a08cc944e1dbb020eadbc0de96508"></a><br/></td></tr>
<tr class="separator:ga2d2a08cc944e1dbb020eadbc0de96508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73450c8842822a9159ef22cfbdca1adb"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga73450c8842822a9159ef22cfbdca1adb"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor5&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga73450c8842822a9159ef22cfbdca1adb">sigc::mem_fun5</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr class="memdesc:ga73450c8842822a9159ef22cfbdca1adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance.">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance. <a href="#ga73450c8842822a9159ef22cfbdca1adb"></a><br/></td></tr>
<tr class="separator:ga73450c8842822a9159ef22cfbdca1adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafba7801841d4c0c7d11f38f43d539831"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gafba7801841d4c0c7d11f38f43d539831"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor6&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gafba7801841d4c0c7d11f38f43d539831">sigc::mem_fun6</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr class="memdesc:gafba7801841d4c0c7d11f38f43d539831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance.">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance. <a href="#gafba7801841d4c0c7d11f38f43d539831"></a><br/></td></tr>
<tr class="separator:gafba7801841d4c0c7d11f38f43d539831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac928ab55a792369f529a8c270c17da3a"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gac928ab55a792369f529a8c270c17da3a"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor6&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gac928ab55a792369f529a8c270c17da3a">sigc::mem_fun6</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr class="memdesc:gac928ab55a792369f529a8c270c17da3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance.">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance. <a href="#gac928ab55a792369f529a8c270c17da3a"></a><br/></td></tr>
<tr class="separator:gac928ab55a792369f529a8c270c17da3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbbf9f8959def7c6bff925980e11097d"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gacbbf9f8959def7c6bff925980e11097d"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor7&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gacbbf9f8959def7c6bff925980e11097d">sigc::mem_fun7</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr class="memdesc:gacbbf9f8959def7c6bff925980e11097d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance.">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance. <a href="#gacbbf9f8959def7c6bff925980e11097d"></a><br/></td></tr>
<tr class="separator:gacbbf9f8959def7c6bff925980e11097d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe7aa150fe88e0ddac5109aec246dedf"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gafe7aa150fe88e0ddac5109aec246dedf"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor7&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gafe7aa150fe88e0ddac5109aec246dedf">sigc::mem_fun7</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr class="memdesc:gafe7aa150fe88e0ddac5109aec246dedf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance.">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance. <a href="#gafe7aa150fe88e0ddac5109aec246dedf"></a><br/></td></tr>
<tr class="separator:gafe7aa150fe88e0ddac5109aec246dedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52244864d2f65f072678b682bfc9913f"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga52244864d2f65f072678b682bfc9913f"><td class="memTemplItemLeft" align="right" valign="top">mem_functor0&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga52244864d2f65f072678b682bfc9913f">sigc::mem_fun</a> (T_return(T_obj::* _A_func)())</td></tr>
<tr class="memdesc:ga52244864d2f65f072678b682bfc9913f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor0.html" title="mem_functor0 wraps methods with 0 argument(s).">sigc::mem_functor0</a> which wraps a method. <a href="#ga52244864d2f65f072678b682bfc9913f"></a><br/></td></tr>
<tr class="separator:ga52244864d2f65f072678b682bfc9913f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafef5a8105ede7f183a1326c63b96ec85"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gafef5a8105ede7f183a1326c63b96ec85"><td class="memTemplItemLeft" align="right" valign="top">mem_functor1&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gafef5a8105ede7f183a1326c63b96ec85">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1))</td></tr>
<tr class="memdesc:gafef5a8105ede7f183a1326c63b96ec85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor1.html" title="mem_functor1 wraps methods with 1 argument(s).">sigc::mem_functor1</a> which wraps a method. <a href="#gafef5a8105ede7f183a1326c63b96ec85"></a><br/></td></tr>
<tr class="separator:gafef5a8105ede7f183a1326c63b96ec85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5a9fe1ac29acc800bceecfd29c4c785"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gaf5a9fe1ac29acc800bceecfd29c4c785"><td class="memTemplItemLeft" align="right" valign="top">mem_functor2&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaf5a9fe1ac29acc800bceecfd29c4c785">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr class="memdesc:gaf5a9fe1ac29acc800bceecfd29c4c785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor2.html" title="mem_functor2 wraps methods with 2 argument(s).">sigc::mem_functor2</a> which wraps a method. <a href="#gaf5a9fe1ac29acc800bceecfd29c4c785"></a><br/></td></tr>
<tr class="separator:gaf5a9fe1ac29acc800bceecfd29c4c785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd935ed360f79df6ac76d577a3628cfc"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gadd935ed360f79df6ac76d577a3628cfc"><td class="memTemplItemLeft" align="right" valign="top">mem_functor3&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gadd935ed360f79df6ac76d577a3628cfc">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr class="memdesc:gadd935ed360f79df6ac76d577a3628cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor3.html" title="mem_functor3 wraps methods with 3 argument(s).">sigc::mem_functor3</a> which wraps a method. <a href="#gadd935ed360f79df6ac76d577a3628cfc"></a><br/></td></tr>
<tr class="separator:gadd935ed360f79df6ac76d577a3628cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga658880c7fec0e2d7646ab9bee9a1b6d6"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga658880c7fec0e2d7646ab9bee9a1b6d6"><td class="memTemplItemLeft" align="right" valign="top">mem_functor4&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga658880c7fec0e2d7646ab9bee9a1b6d6">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr class="memdesc:ga658880c7fec0e2d7646ab9bee9a1b6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor4.html" title="mem_functor4 wraps methods with 4 argument(s).">sigc::mem_functor4</a> which wraps a method. <a href="#ga658880c7fec0e2d7646ab9bee9a1b6d6"></a><br/></td></tr>
<tr class="separator:ga658880c7fec0e2d7646ab9bee9a1b6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d3509fb8e958e0bc0c5cd312b9140dd"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga3d3509fb8e958e0bc0c5cd312b9140dd"><td class="memTemplItemLeft" align="right" valign="top">mem_functor5&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga3d3509fb8e958e0bc0c5cd312b9140dd">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr class="memdesc:ga3d3509fb8e958e0bc0c5cd312b9140dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor5.html" title="mem_functor5 wraps methods with 5 argument(s).">sigc::mem_functor5</a> which wraps a method. <a href="#ga3d3509fb8e958e0bc0c5cd312b9140dd"></a><br/></td></tr>
<tr class="separator:ga3d3509fb8e958e0bc0c5cd312b9140dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a670ee63fe536feb0bc6d70d3a17da0"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga4a670ee63fe536feb0bc6d70d3a17da0"><td class="memTemplItemLeft" align="right" valign="top">mem_functor6&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga4a670ee63fe536feb0bc6d70d3a17da0">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr class="memdesc:ga4a670ee63fe536feb0bc6d70d3a17da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor6.html" title="mem_functor6 wraps methods with 6 argument(s).">sigc::mem_functor6</a> which wraps a method. <a href="#ga4a670ee63fe536feb0bc6d70d3a17da0"></a><br/></td></tr>
<tr class="separator:ga4a670ee63fe536feb0bc6d70d3a17da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff7c688cda469057de1986106d2afbdf"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gaff7c688cda469057de1986106d2afbdf"><td class="memTemplItemLeft" align="right" valign="top">mem_functor7&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaff7c688cda469057de1986106d2afbdf">sigc::mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr class="memdesc:gaff7c688cda469057de1986106d2afbdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor7.html" title="mem_functor7 wraps methods with 7 argument(s).">sigc::mem_functor7</a> which wraps a method. <a href="#gaff7c688cda469057de1986106d2afbdf"></a><br/></td></tr>
<tr class="separator:gaff7c688cda469057de1986106d2afbdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59dbc2d36afa5ee13876d0ee4c3efcba"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga59dbc2d36afa5ee13876d0ee4c3efcba"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor0&lt; T_return, <br class="typebreak"/>
T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga59dbc2d36afa5ee13876d0ee4c3efcba">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)())</td></tr>
<tr class="memdesc:ga59dbc2d36afa5ee13876d0ee4c3efcba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance.">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance. <a href="#ga59dbc2d36afa5ee13876d0ee4c3efcba"></a><br/></td></tr>
<tr class="separator:ga59dbc2d36afa5ee13876d0ee4c3efcba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga880680f83a13cfa9cec0aac27d85cc4e"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga880680f83a13cfa9cec0aac27d85cc4e"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor0&lt; T_return, <br class="typebreak"/>
T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga880680f83a13cfa9cec0aac27d85cc4e">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)())</td></tr>
<tr class="memdesc:ga880680f83a13cfa9cec0aac27d85cc4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance.">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance. <a href="#ga880680f83a13cfa9cec0aac27d85cc4e"></a><br/></td></tr>
<tr class="separator:ga880680f83a13cfa9cec0aac27d85cc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e522ebdadfce0b7bf7919a002689206"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga4e522ebdadfce0b7bf7919a002689206"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor1&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga4e522ebdadfce0b7bf7919a002689206">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>
<tr class="memdesc:ga4e522ebdadfce0b7bf7919a002689206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance.">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance. <a href="#ga4e522ebdadfce0b7bf7919a002689206"></a><br/></td></tr>
<tr class="separator:ga4e522ebdadfce0b7bf7919a002689206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c4f25e76b5f05a52cb13610a6713e06"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga1c4f25e76b5f05a52cb13610a6713e06"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor1&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga1c4f25e76b5f05a52cb13610a6713e06">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>
<tr class="memdesc:ga1c4f25e76b5f05a52cb13610a6713e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance.">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance. <a href="#ga1c4f25e76b5f05a52cb13610a6713e06"></a><br/></td></tr>
<tr class="separator:ga1c4f25e76b5f05a52cb13610a6713e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8a032173da28ce2f70e60b68c85b59f"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gac8a032173da28ce2f70e60b68c85b59f"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor2&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gac8a032173da28ce2f70e60b68c85b59f">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr class="memdesc:gac8a032173da28ce2f70e60b68c85b59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance.">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance. <a href="#gac8a032173da28ce2f70e60b68c85b59f"></a><br/></td></tr>
<tr class="separator:gac8a032173da28ce2f70e60b68c85b59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d73a765ca6fbeceea48962319972eb2"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga1d73a765ca6fbeceea48962319972eb2"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor2&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga1d73a765ca6fbeceea48962319972eb2">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr class="memdesc:ga1d73a765ca6fbeceea48962319972eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance.">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance. <a href="#ga1d73a765ca6fbeceea48962319972eb2"></a><br/></td></tr>
<tr class="separator:ga1d73a765ca6fbeceea48962319972eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf67c13f2600b3adee5d71c720e34f200"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaf67c13f2600b3adee5d71c720e34f200"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor3&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaf67c13f2600b3adee5d71c720e34f200">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr class="memdesc:gaf67c13f2600b3adee5d71c720e34f200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance.">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance. <a href="#gaf67c13f2600b3adee5d71c720e34f200"></a><br/></td></tr>
<tr class="separator:gaf67c13f2600b3adee5d71c720e34f200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb986cff130c08774b2b273a7130bfa4"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gafb986cff130c08774b2b273a7130bfa4"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor3&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gafb986cff130c08774b2b273a7130bfa4">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr class="memdesc:gafb986cff130c08774b2b273a7130bfa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance.">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance. <a href="#gafb986cff130c08774b2b273a7130bfa4"></a><br/></td></tr>
<tr class="separator:gafb986cff130c08774b2b273a7130bfa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9289d4ffd3df262fa70c4997713f30f2"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga9289d4ffd3df262fa70c4997713f30f2"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor4&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga9289d4ffd3df262fa70c4997713f30f2">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr class="memdesc:ga9289d4ffd3df262fa70c4997713f30f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance.">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance. <a href="#ga9289d4ffd3df262fa70c4997713f30f2"></a><br/></td></tr>
<tr class="separator:ga9289d4ffd3df262fa70c4997713f30f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga104fe5c3642e3e090cfd3a28b71277fb"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga104fe5c3642e3e090cfd3a28b71277fb"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor4&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga104fe5c3642e3e090cfd3a28b71277fb">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr class="memdesc:ga104fe5c3642e3e090cfd3a28b71277fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance.">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance. <a href="#ga104fe5c3642e3e090cfd3a28b71277fb"></a><br/></td></tr>
<tr class="separator:ga104fe5c3642e3e090cfd3a28b71277fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf60bdc06ae0f6c3ef711b018987028dc"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaf60bdc06ae0f6c3ef711b018987028dc"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor5&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaf60bdc06ae0f6c3ef711b018987028dc">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr class="memdesc:gaf60bdc06ae0f6c3ef711b018987028dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance.">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance. <a href="#gaf60bdc06ae0f6c3ef711b018987028dc"></a><br/></td></tr>
<tr class="separator:gaf60bdc06ae0f6c3ef711b018987028dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3233d1890d3de2865c3ee31b8dad943"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gac3233d1890d3de2865c3ee31b8dad943"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor5&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gac3233d1890d3de2865c3ee31b8dad943">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr class="memdesc:gac3233d1890d3de2865c3ee31b8dad943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance.">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance. <a href="#gac3233d1890d3de2865c3ee31b8dad943"></a><br/></td></tr>
<tr class="separator:gac3233d1890d3de2865c3ee31b8dad943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2f919081dbdb355280fee7c03d38e2b"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gac2f919081dbdb355280fee7c03d38e2b"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor6&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gac2f919081dbdb355280fee7c03d38e2b">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr class="memdesc:gac2f919081dbdb355280fee7c03d38e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance.">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance. <a href="#gac2f919081dbdb355280fee7c03d38e2b"></a><br/></td></tr>
<tr class="separator:gac2f919081dbdb355280fee7c03d38e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97a2b07475e715526bb233f193d22b0c"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga97a2b07475e715526bb233f193d22b0c"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor6&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga97a2b07475e715526bb233f193d22b0c">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr class="memdesc:ga97a2b07475e715526bb233f193d22b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance.">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance. <a href="#ga97a2b07475e715526bb233f193d22b0c"></a><br/></td></tr>
<tr class="separator:ga97a2b07475e715526bb233f193d22b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga155503aac650f7d8a575de477d1b3334"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga155503aac650f7d8a575de477d1b3334"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor7&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga155503aac650f7d8a575de477d1b3334">sigc::mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr class="memdesc:ga155503aac650f7d8a575de477d1b3334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance.">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance. <a href="#ga155503aac650f7d8a575de477d1b3334"></a><br/></td></tr>
<tr class="separator:ga155503aac650f7d8a575de477d1b3334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga560c76b57874fef9e3a1cc113276edad"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga560c76b57874fef9e3a1cc113276edad"><td class="memTemplItemLeft" align="right" valign="top">bound_mem_functor7&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga560c76b57874fef9e3a1cc113276edad">sigc::mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr class="memdesc:ga560c76b57874fef9e3a1cc113276edad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance.">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance. <a href="#ga560c76b57874fef9e3a1cc113276edad"></a><br/></td></tr>
<tr class="separator:ga560c76b57874fef9e3a1cc113276edad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><a class="el" href="group__mem__fun.html#ga52244864d2f65f072678b682bfc9913f" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">mem_fun()</a> is used to convert a pointer to a method to a functor. </p>
<p>Optionally, a reference or pointer to an object can be bound to the functor. Note that only if the object type inherits from <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection.">sigc::trackable</a> is the slot automatically cleared when the object goes out of scope!</p>
<p>If the member function pointer is to an overloaded type, you must specify the types using template arguments starting with the first argument. It is not necessary to supply the return type.</p>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><span class="keyword">struct </span>foo : <span class="keyword">public</span> <a class="code" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection.">sigc::trackable</a></div>
<div class="line">{</div>
<div class="line"> <span class="keywordtype">void</span> bar(<span class="keywordtype">int</span>) {}</div>
<div class="line">};</div>
<div class="line">foo my_foo;</div>
<div class="line"><a class="code" href="classsigc_1_1slot.html" title="Convenience wrapper for the numbered sigc::slot# templates.">sigc::slot&lt;void, int&gt;</a> sl = <a class="code" href="group__mem__fun.html#ga52244864d2f65f072678b682bfc9913f" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun</a>(my_foo, &amp;foo::bar);</div>
</div><!-- fragment --></dd></dl>
<p>For const methods <a class="el" href="group__mem__fun.html#ga52244864d2f65f072678b682bfc9913f" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">mem_fun()</a> takes a const reference or pointer to an object.</p>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><span class="keyword">struct </span>foo : <span class="keyword">public</span> <a class="code" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection.">sigc::trackable</a></div>
<div class="line">{</div>
<div class="line"> <span class="keywordtype">void</span> bar(<span class="keywordtype">int</span>)<span class="keyword"> const </span>{}</div>
<div class="line">};</div>
<div class="line"><span class="keyword">const</span> foo my_foo;</div>
<div class="line"><a class="code" href="classsigc_1_1slot.html" title="Convenience wrapper for the numbered sigc::slot# templates.">sigc::slot&lt;void, int&gt;</a> sl = <a class="code" href="group__mem__fun.html#ga52244864d2f65f072678b682bfc9913f" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">sigc::mem_fun</a>(my_foo, &amp;foo::bar);</div>
</div><!-- fragment --></dd></dl>
<p>Use mem_fun#() if there is an ambiguity as to the number of arguments.</p>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><span class="keyword">struct </span>foo : <span class="keyword">public</span> <a class="code" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection.">sigc::trackable</a></div>
<div class="line">{</div>
<div class="line"> <span class="keywordtype">void</span> bar(<span class="keywordtype">int</span>) {}</div>
<div class="line"> <span class="keywordtype">void</span> bar(<span class="keywordtype">float</span>) {}</div>
<div class="line"> <span class="keywordtype">void</span> bar(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>) {}</div>
<div class="line">};</div>
<div class="line">foo my_foo;</div>
<div class="line"><a class="code" href="classsigc_1_1slot.html" title="Convenience wrapper for the numbered sigc::slot# templates.">sigc::slot&lt;void, int&gt;</a> sl = sigc::mem_fun1&lt;int&gt;(my_foo, &amp;foo::bar);</div>
</div><!-- fragment --> </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga52244864d2f65f072678b682bfc9913f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor0&lt; T_return, T_obj &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)()&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor0.html" title="mem_functor0 wraps methods with 0 argument(s).">sigc::mem_functor0</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html" title="const_volatile_mem_functor0 wraps const volatile methods with 0 argument(s).">sigc::const_volatile_mem_functor0</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor0.html" title="volatile_mem_functor0 wraps volatile methods with 0 argument(s).">sigc::volatile_mem_functor0</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor0.html" title="const_mem_functor0 wraps const methods with 0 argument(s).">sigc::const_mem_functor0</a> which wraps a const method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gafef5a8105ede7f183a1326c63b96ec85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1)&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor1.html" title="mem_functor1 wraps methods with 1 argument(s).">sigc::mem_functor1</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html" title="const_volatile_mem_functor1 wraps const volatile methods with 1 argument(s).">sigc::const_volatile_mem_functor1</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor1.html" title="volatile_mem_functor1 wraps volatile methods with 1 argument(s).">sigc::volatile_mem_functor1</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor1.html" title="const_mem_functor1 wraps const methods with 1 argument(s).">sigc::const_mem_functor1</a> which wraps a const method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf5a9fe1ac29acc800bceecfd29c4c785"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2)&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor2.html" title="mem_functor2 wraps methods with 2 argument(s).">sigc::mem_functor2</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html" title="const_volatile_mem_functor2 wraps const volatile methods with 2 argument(s).">sigc::const_volatile_mem_functor2</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor2.html" title="volatile_mem_functor2 wraps volatile methods with 2 argument(s).">sigc::volatile_mem_functor2</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor2.html" title="const_mem_functor2 wraps const methods with 2 argument(s).">sigc::const_mem_functor2</a> which wraps a const method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gadd935ed360f79df6ac76d577a3628cfc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3)&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor3.html" title="mem_functor3 wraps methods with 3 argument(s).">sigc::mem_functor3</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html" title="const_volatile_mem_functor3 wraps const volatile methods with 3 argument(s).">sigc::const_volatile_mem_functor3</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor3.html" title="volatile_mem_functor3 wraps volatile methods with 3 argument(s).">sigc::volatile_mem_functor3</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor3.html" title="const_mem_functor3 wraps const methods with 3 argument(s).">sigc::const_mem_functor3</a> which wraps a const method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga658880c7fec0e2d7646ab9bee9a1b6d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4)&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor4.html" title="mem_functor4 wraps methods with 4 argument(s).">sigc::mem_functor4</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html" title="const_volatile_mem_functor4 wraps const volatile methods with 4 argument(s).">sigc::const_volatile_mem_functor4</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor4.html" title="volatile_mem_functor4 wraps volatile methods with 4 argument(s).">sigc::volatile_mem_functor4</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor4.html" title="const_mem_functor4 wraps const methods with 4 argument(s).">sigc::const_mem_functor4</a> which wraps a const method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3d3509fb8e958e0bc0c5cd312b9140dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor5.html" title="mem_functor5 wraps methods with 5 argument(s).">sigc::mem_functor5</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html" title="const_volatile_mem_functor5 wraps const volatile methods with 5 argument(s).">sigc::const_volatile_mem_functor5</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor5.html" title="volatile_mem_functor5 wraps volatile methods with 5 argument(s).">sigc::volatile_mem_functor5</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor5.html" title="const_mem_functor5 wraps const methods with 5 argument(s).">sigc::const_mem_functor5</a> which wraps a const method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4a670ee63fe536feb0bc6d70d3a17da0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor6.html" title="mem_functor6 wraps methods with 6 argument(s).">sigc::mem_functor6</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html" title="const_volatile_mem_functor6 wraps const volatile methods with 6 argument(s).">sigc::const_volatile_mem_functor6</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor6.html" title="volatile_mem_functor6 wraps volatile methods with 6 argument(s).">sigc::volatile_mem_functor6</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor6.html" title="const_mem_functor6 wraps const methods with 6 argument(s).">sigc::const_mem_functor6</a> which wraps a const method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaff7c688cda469057de1986106d2afbdf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7)&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor7.html" title="mem_functor7 wraps methods with 7 argument(s).">sigc::mem_functor7</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html" title="const_volatile_mem_functor7 wraps const volatile methods with 7 argument(s).">sigc::const_volatile_mem_functor7</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor7.html" title="volatile_mem_functor7 wraps volatile methods with 7 argument(s).">sigc::volatile_mem_functor7</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor7.html" title="const_mem_functor7 wraps const methods with 7 argument(s).">sigc::const_mem_functor7</a> which wraps a const method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga59dbc2d36afa5ee13876d0ee4c3efcba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor0&lt; T_return, T_obj &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)()&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance.">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html" title="bound_const_volatile_mem_functor0 encapsulates a const volatile method with 0 arguments and an object...">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html" title="bound_volatile_mem_functor0 encapsulates a volatile method with 0 arguments and an object instance...">sigc::bound_volatile_mem_functor0</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html" title="bound_const_mem_functor0 encapsulates a const method with 0 arguments and an object instance...">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga880680f83a13cfa9cec0aac27d85cc4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor0&lt; T_return, T_obj &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)()&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance.">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html" title="bound_const_volatile_mem_functor0 encapsulates a const volatile method with 0 arguments and an object...">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html" title="bound_volatile_mem_functor0 encapsulates a volatile method with 0 arguments and an object instance...">sigc::bound_volatile_mem_functor0</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html" title="bound_const_mem_functor0 encapsulates a const method with 0 arguments and an object instance...">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4e522ebdadfce0b7bf7919a002689206"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance.">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html" title="bound_const_volatile_mem_functor1 encapsulates a const volatile method with 1 arguments and an object...">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html" title="bound_volatile_mem_functor1 encapsulates a volatile method with 1 arguments and an object instance...">sigc::bound_volatile_mem_functor1</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html" title="bound_const_mem_functor1 encapsulates a const method with 1 arguments and an object instance...">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1c4f25e76b5f05a52cb13610a6713e06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance.">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html" title="bound_const_volatile_mem_functor1 encapsulates a const volatile method with 1 arguments and an object...">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html" title="bound_volatile_mem_functor1 encapsulates a volatile method with 1 arguments and an object instance...">sigc::bound_volatile_mem_functor1</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html" title="bound_const_mem_functor1 encapsulates a const method with 1 arguments and an object instance...">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gac8a032173da28ce2f70e60b68c85b59f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance.">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html" title="bound_const_volatile_mem_functor2 encapsulates a const volatile method with 2 arguments and an object...">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html" title="bound_volatile_mem_functor2 encapsulates a volatile method with 2 arguments and an object instance...">sigc::bound_volatile_mem_functor2</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html" title="bound_const_mem_functor2 encapsulates a const method with 2 arguments and an object instance...">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1d73a765ca6fbeceea48962319972eb2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance.">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html" title="bound_const_volatile_mem_functor2 encapsulates a const volatile method with 2 arguments and an object...">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html" title="bound_volatile_mem_functor2 encapsulates a volatile method with 2 arguments and an object instance...">sigc::bound_volatile_mem_functor2</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html" title="bound_const_mem_functor2 encapsulates a const method with 2 arguments and an object instance...">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf67c13f2600b3adee5d71c720e34f200"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance.">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html" title="bound_const_volatile_mem_functor3 encapsulates a const volatile method with 3 arguments and an object...">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html" title="bound_volatile_mem_functor3 encapsulates a volatile method with 3 arguments and an object instance...">sigc::bound_volatile_mem_functor3</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html" title="bound_const_mem_functor3 encapsulates a const method with 3 arguments and an object instance...">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gafb986cff130c08774b2b273a7130bfa4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance.">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html" title="bound_const_volatile_mem_functor3 encapsulates a const volatile method with 3 arguments and an object...">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html" title="bound_volatile_mem_functor3 encapsulates a volatile method with 3 arguments and an object instance...">sigc::bound_volatile_mem_functor3</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html" title="bound_const_mem_functor3 encapsulates a const method with 3 arguments and an object instance...">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9289d4ffd3df262fa70c4997713f30f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance.">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html" title="bound_const_volatile_mem_functor4 encapsulates a const volatile method with 4 arguments and an object...">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html" title="bound_volatile_mem_functor4 encapsulates a volatile method with 4 arguments and an object instance...">sigc::bound_volatile_mem_functor4</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html" title="bound_const_mem_functor4 encapsulates a const method with 4 arguments and an object instance...">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga104fe5c3642e3e090cfd3a28b71277fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance.">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html" title="bound_const_volatile_mem_functor4 encapsulates a const volatile method with 4 arguments and an object...">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html" title="bound_volatile_mem_functor4 encapsulates a volatile method with 4 arguments and an object instance...">sigc::bound_volatile_mem_functor4</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html" title="bound_const_mem_functor4 encapsulates a const method with 4 arguments and an object instance...">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf60bdc06ae0f6c3ef711b018987028dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance.">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html" title="bound_const_volatile_mem_functor5 encapsulates a const volatile method with 5 arguments and an object...">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html" title="bound_volatile_mem_functor5 encapsulates a volatile method with 5 arguments and an object instance...">sigc::bound_volatile_mem_functor5</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html" title="bound_const_mem_functor5 encapsulates a const method with 5 arguments and an object instance...">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gac3233d1890d3de2865c3ee31b8dad943"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance.">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html" title="bound_const_volatile_mem_functor5 encapsulates a const volatile method with 5 arguments and an object...">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html" title="bound_volatile_mem_functor5 encapsulates a volatile method with 5 arguments and an object instance...">sigc::bound_volatile_mem_functor5</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html" title="bound_const_mem_functor5 encapsulates a const method with 5 arguments and an object instance...">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gac2f919081dbdb355280fee7c03d38e2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance.">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html" title="bound_const_volatile_mem_functor6 encapsulates a const volatile method with 6 arguments and an object...">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html" title="bound_volatile_mem_functor6 encapsulates a volatile method with 6 arguments and an object instance...">sigc::bound_volatile_mem_functor6</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html" title="bound_const_mem_functor6 encapsulates a const method with 6 arguments and an object instance...">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga97a2b07475e715526bb233f193d22b0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance.">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html" title="bound_const_volatile_mem_functor6 encapsulates a const volatile method with 6 arguments and an object...">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html" title="bound_volatile_mem_functor6 encapsulates a volatile method with 6 arguments and an object instance...">sigc::bound_volatile_mem_functor6</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html" title="bound_const_mem_functor6 encapsulates a const method with 6 arguments and an object instance...">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga155503aac650f7d8a575de477d1b3334"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance.">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html" title="bound_const_volatile_mem_functor7 encapsulates a const volatile method with 7 arguments and an object...">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html" title="bound_volatile_mem_functor7 encapsulates a volatile method with 7 arguments and an object instance...">sigc::bound_volatile_mem_functor7</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html" title="bound_const_mem_functor7 encapsulates a const method with 7 arguments and an object instance...">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga560c76b57874fef9e3a1cc113276edad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance.">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html" title="bound_const_volatile_mem_functor7 encapsulates a const volatile method with 7 arguments and an object...">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html" title="bound_volatile_mem_functor7 encapsulates a volatile method with 7 arguments and an object instance...">sigc::bound_volatile_mem_functor7</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html" title="bound_const_mem_functor7 encapsulates a const method with 7 arguments and an object instance...">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga54eb73c592288db072ae8fdcd0271809"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor0&lt; T_return, T_obj &gt; sigc::mem_fun0 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)()&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor0.html" title="mem_functor0 wraps methods with 0 argument(s).">sigc::mem_functor0</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html" title="const_volatile_mem_functor0 wraps const volatile methods with 0 argument(s).">sigc::const_volatile_mem_functor0</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor0.html" title="volatile_mem_functor0 wraps volatile methods with 0 argument(s).">sigc::volatile_mem_functor0</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor0.html" title="const_mem_functor0 wraps const methods with 0 argument(s).">sigc::const_mem_functor0</a> which wraps a const method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7d417e21d7f2da74454e2b6cbd8e136d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor0&lt; T_return, T_obj &gt; sigc::mem_fun0 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)()&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance.">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html" title="bound_const_volatile_mem_functor0 encapsulates a const volatile method with 0 arguments and an object...">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html" title="bound_volatile_mem_functor0 encapsulates a volatile method with 0 arguments and an object instance...">sigc::bound_volatile_mem_functor0</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html" title="bound_const_mem_functor0 encapsulates a const method with 0 arguments and an object instance...">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga32580882b3288eb20b75a8c886a2e082"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor0&lt; T_return, T_obj &gt; sigc::mem_fun0 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)()&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance.">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html" title="bound_const_volatile_mem_functor0 encapsulates a const volatile method with 0 arguments and an object...">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html" title="bound_volatile_mem_functor0 encapsulates a volatile method with 0 arguments and an object instance...">sigc::bound_volatile_mem_functor0</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html" title="bound_const_mem_functor0 encapsulates a const method with 0 arguments and an object instance...">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gafa89ed057c5d4a3fe7725f36840c2663"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; sigc::mem_fun1 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1)&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor1.html" title="mem_functor1 wraps methods with 1 argument(s).">sigc::mem_functor1</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html" title="const_volatile_mem_functor1 wraps const volatile methods with 1 argument(s).">sigc::const_volatile_mem_functor1</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor1.html" title="volatile_mem_functor1 wraps volatile methods with 1 argument(s).">sigc::volatile_mem_functor1</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor1.html" title="const_mem_functor1 wraps const methods with 1 argument(s).">sigc::const_mem_functor1</a> which wraps a const method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gadf1d0a1f044abdc784aa4fbcf9b827bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; sigc::mem_fun1 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance.">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html" title="bound_const_volatile_mem_functor1 encapsulates a const volatile method with 1 arguments and an object...">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html" title="bound_volatile_mem_functor1 encapsulates a volatile method with 1 arguments and an object instance...">sigc::bound_volatile_mem_functor1</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html" title="bound_const_mem_functor1 encapsulates a const method with 1 arguments and an object instance...">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gab06ac23be30f9440af97b816e66cac06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; sigc::mem_fun1 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance.">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html" title="bound_const_volatile_mem_functor1 encapsulates a const volatile method with 1 arguments and an object...">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html" title="bound_volatile_mem_functor1 encapsulates a volatile method with 1 arguments and an object instance...">sigc::bound_volatile_mem_functor1</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html" title="bound_const_mem_functor1 encapsulates a const method with 1 arguments and an object instance...">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gae58a6e612c3ddc06be3a23c261636442"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; sigc::mem_fun2 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2)&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor2.html" title="mem_functor2 wraps methods with 2 argument(s).">sigc::mem_functor2</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html" title="const_volatile_mem_functor2 wraps const volatile methods with 2 argument(s).">sigc::const_volatile_mem_functor2</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor2.html" title="volatile_mem_functor2 wraps volatile methods with 2 argument(s).">sigc::volatile_mem_functor2</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor2.html" title="const_mem_functor2 wraps const methods with 2 argument(s).">sigc::const_mem_functor2</a> which wraps a const method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga78bc4c78ef14d8b7adcb7cfcfc098516"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; sigc::mem_fun2 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance.">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html" title="bound_const_volatile_mem_functor2 encapsulates a const volatile method with 2 arguments and an object...">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html" title="bound_volatile_mem_functor2 encapsulates a volatile method with 2 arguments and an object instance...">sigc::bound_volatile_mem_functor2</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html" title="bound_const_mem_functor2 encapsulates a const method with 2 arguments and an object instance...">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaae5eb7ef1e372250026726f7b7ed3855"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; sigc::mem_fun2 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance.">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html" title="bound_const_volatile_mem_functor2 encapsulates a const volatile method with 2 arguments and an object...">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html" title="bound_volatile_mem_functor2 encapsulates a volatile method with 2 arguments and an object instance...">sigc::bound_volatile_mem_functor2</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html" title="bound_const_mem_functor2 encapsulates a const method with 2 arguments and an object instance...">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gabf8d584369e2c7d7b3cfea0ad6094a08"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; sigc::mem_fun3 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3)&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor3.html" title="mem_functor3 wraps methods with 3 argument(s).">sigc::mem_functor3</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html" title="const_volatile_mem_functor3 wraps const volatile methods with 3 argument(s).">sigc::const_volatile_mem_functor3</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor3.html" title="volatile_mem_functor3 wraps volatile methods with 3 argument(s).">sigc::volatile_mem_functor3</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor3.html" title="const_mem_functor3 wraps const methods with 3 argument(s).">sigc::const_mem_functor3</a> which wraps a const method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2dd21580bac297f5c524a61de335ff1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; sigc::mem_fun3 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance.">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html" title="bound_const_volatile_mem_functor3 encapsulates a const volatile method with 3 arguments and an object...">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html" title="bound_volatile_mem_functor3 encapsulates a volatile method with 3 arguments and an object instance...">sigc::bound_volatile_mem_functor3</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html" title="bound_const_mem_functor3 encapsulates a const method with 3 arguments and an object instance...">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gade548b8b0e42109cfa9c798e185649b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; sigc::mem_fun3 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance.">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html" title="bound_const_volatile_mem_functor3 encapsulates a const volatile method with 3 arguments and an object...">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html" title="bound_volatile_mem_functor3 encapsulates a volatile method with 3 arguments and an object instance...">sigc::bound_volatile_mem_functor3</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html" title="bound_const_mem_functor3 encapsulates a const method with 3 arguments and an object instance...">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaef2aecfa6f95d7b5fdb3b9d2b43dad23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; sigc::mem_fun4 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4)&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor4.html" title="mem_functor4 wraps methods with 4 argument(s).">sigc::mem_functor4</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html" title="const_volatile_mem_functor4 wraps const volatile methods with 4 argument(s).">sigc::const_volatile_mem_functor4</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor4.html" title="volatile_mem_functor4 wraps volatile methods with 4 argument(s).">sigc::volatile_mem_functor4</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor4.html" title="const_mem_functor4 wraps const methods with 4 argument(s).">sigc::const_mem_functor4</a> which wraps a const method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3b4680747cc51964f04827b1febfe8fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; sigc::mem_fun4 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance.">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html" title="bound_const_volatile_mem_functor4 encapsulates a const volatile method with 4 arguments and an object...">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html" title="bound_volatile_mem_functor4 encapsulates a volatile method with 4 arguments and an object instance...">sigc::bound_volatile_mem_functor4</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html" title="bound_const_mem_functor4 encapsulates a const method with 4 arguments and an object instance...">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga05a5dce6cbcfd3947857c3f2dd62699c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; sigc::mem_fun4 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance.">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html" title="bound_const_volatile_mem_functor4 encapsulates a const volatile method with 4 arguments and an object...">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html" title="bound_volatile_mem_functor4 encapsulates a volatile method with 4 arguments and an object instance...">sigc::bound_volatile_mem_functor4</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html" title="bound_const_mem_functor4 encapsulates a const method with 4 arguments and an object instance...">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8b15cb11f5ecd0806f391f0e88a3c92a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; sigc::mem_fun5 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor5.html" title="mem_functor5 wraps methods with 5 argument(s).">sigc::mem_functor5</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html" title="const_volatile_mem_functor5 wraps const volatile methods with 5 argument(s).">sigc::const_volatile_mem_functor5</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor5.html" title="volatile_mem_functor5 wraps volatile methods with 5 argument(s).">sigc::volatile_mem_functor5</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor5.html" title="const_mem_functor5 wraps const methods with 5 argument(s).">sigc::const_mem_functor5</a> which wraps a const method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2d2a08cc944e1dbb020eadbc0de96508"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; sigc::mem_fun5 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance.">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html" title="bound_const_volatile_mem_functor5 encapsulates a const volatile method with 5 arguments and an object...">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html" title="bound_volatile_mem_functor5 encapsulates a volatile method with 5 arguments and an object instance...">sigc::bound_volatile_mem_functor5</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html" title="bound_const_mem_functor5 encapsulates a const method with 5 arguments and an object instance...">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga73450c8842822a9159ef22cfbdca1adb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; sigc::mem_fun5 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance.">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html" title="bound_const_volatile_mem_functor5 encapsulates a const volatile method with 5 arguments and an object...">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html" title="bound_volatile_mem_functor5 encapsulates a volatile method with 5 arguments and an object instance...">sigc::bound_volatile_mem_functor5</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html" title="bound_const_mem_functor5 encapsulates a const method with 5 arguments and an object instance...">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6705d585efb6c716ddb71c3eb0b0987c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; sigc::mem_fun6 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor6.html" title="mem_functor6 wraps methods with 6 argument(s).">sigc::mem_functor6</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html" title="const_volatile_mem_functor6 wraps const volatile methods with 6 argument(s).">sigc::const_volatile_mem_functor6</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor6.html" title="volatile_mem_functor6 wraps volatile methods with 6 argument(s).">sigc::volatile_mem_functor6</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor6.html" title="const_mem_functor6 wraps const methods with 6 argument(s).">sigc::const_mem_functor6</a> which wraps a const method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gafba7801841d4c0c7d11f38f43d539831"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; sigc::mem_fun6 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance.">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html" title="bound_const_volatile_mem_functor6 encapsulates a const volatile method with 6 arguments and an object...">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html" title="bound_volatile_mem_functor6 encapsulates a volatile method with 6 arguments and an object instance...">sigc::bound_volatile_mem_functor6</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html" title="bound_const_mem_functor6 encapsulates a const method with 6 arguments and an object instance...">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gac928ab55a792369f529a8c270c17da3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; sigc::mem_fun6 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance.">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html" title="bound_const_volatile_mem_functor6 encapsulates a const volatile method with 6 arguments and an object...">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html" title="bound_volatile_mem_functor6 encapsulates a volatile method with 6 arguments and an object instance...">sigc::bound_volatile_mem_functor6</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html" title="bound_const_mem_functor6 encapsulates a const method with 6 arguments and an object instance...">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gac74d8545aaf4999fe944157aef43ee30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; sigc::mem_fun7 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7)&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1mem__functor7.html" title="mem_functor7 wraps methods with 7 argument(s).">sigc::mem_functor7</a> which wraps a method. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html" title="const_volatile_mem_functor7 wraps const volatile methods with 7 argument(s).">sigc::const_volatile_mem_functor7</a> which wraps a const volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor7.html" title="volatile_mem_functor7 wraps volatile methods with 7 argument(s).">sigc::volatile_mem_functor7</a> which wraps a volatile method.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor7.html" title="const_mem_functor7 wraps const methods with 7 argument(s).">sigc::const_mem_functor7</a> which wraps a const method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gacbbf9f8959def7c6bff925980e11097d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; sigc::mem_fun7 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance.">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html" title="bound_const_volatile_mem_functor7 encapsulates a const volatile method with 7 arguments and an object...">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html" title="bound_volatile_mem_functor7 encapsulates a volatile method with 7 arguments and an object instance...">sigc::bound_volatile_mem_functor7</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html" title="bound_const_mem_functor7 encapsulates a const method with 7 arguments and an object instance...">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gafe7aa150fe88e0ddac5109aec246dedf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bound_const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; sigc::mem_fun7 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7)&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance.">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance. </p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html" title="bound_const_volatile_mem_functor7 encapsulates a const volatile method with 7 arguments and an object...">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html" title="bound_volatile_mem_functor7 encapsulates a volatile method with 7 arguments and an object instance...">sigc::bound_volatile_mem_functor7</a> which encapsulates a method and an object instance.</p>
<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html" title="bound_const_mem_functor7 encapsulates a const method with 7 arguments and an object instance...">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gabd5e9a64995f5ca0f7895278a9ece6d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_mem_functor0&lt; T_return, T_obj &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga1a18696f671f364cfffb30f0e9611428"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga63da7ee0d100b9e60613617cbd199a8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="gacf7482b0f9a6ea8426f5f1a108ed5539"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="gab85f8b77cba0d3928de62029c8f039e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="gab4d37bcfcf202f48a11e55cb6baadd6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga6ef9a586816c1016e6c8f7b325301ab7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga468e79dd7be56de4a3837b4c5fdde8ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_mem_functor performs a functor on the object instance stored in the sigc::bound_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga7c8e3d85a311ed8946447533b70d0d46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_mem_functor0&lt; T_return, T_obj &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="gaee2a3da2684f1bcf2f53c7827c966867"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="gaec056e796fa861129436436d39aed604"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga79e40b784e00b7c442dcf7e5dba0e7d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="gacf6f7626e673513f7a8850b4f3dd002f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga400f9f2d5b8f8ae4c3efd5291d8c278d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="gaef07c518bd60eb9565c9091ec322476d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga054db7e62e3f4cdc1a43c1c7023df7de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_mem_functor performs a functor on the object instance stored in the sigc::bound_const_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga9778e745dd100d983c7914229bd2560d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_volatile_mem_functor0&lt; T_return, T_obj &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga3de3496749fd7647a85bcf376a4a832f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga469cf869c605b8ecf50fc31113dab706"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="gacab6d2c64c56e650d180005a3170bb19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="gaf8b3078b7d2f36a4b82e09030e2cfa5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="gabb81af568daf632e59e2aeeb073956b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="gadbb697f9fbf040c76368f2a1d778ea7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga0514c3e40acd841d5e9c4ae4b774ded6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="gaca854f6453dccd4a47f36721ddd3965e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_volatile_mem_functor0&lt; T_return, T_obj &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga4c0d65b88a0259e34437f0d0ea322251"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_volatile_mem_functor1&lt; T_return, T_obj, T_arg1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="gae260215430ab2b1ca8b80c40f5d0be00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_volatile_mem_functor2&lt; T_return, T_obj, T_arg1, T_arg2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga3968c8eb9d73ea876c6b312d73e2c4a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_volatile_mem_functor3&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="gabed5fa33913a8234f792d31743004c42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_volatile_mem_functor4&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga75a3dcba51260d7502ec923e8c0be5c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_volatile_mem_functor5&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga3eee29bbfdb0fe95e0d31f32defb4b96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_volatile_mem_functor6&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object. </p>

</div>
</div>
<a class="anchor" id="ga6a0d4084f93bd2b1fcf95a5b495c4427"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_const_volatile_mem_functor7&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a functor on each of the targets of a functor. </p>
<p>The function overload for sigc::bound_const_volatile_mem_functor performs a functor on the object instance stored in the sigc::bound_const_volatile_mem_functor object. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 18 2012 09:28:24 for libsigc++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
