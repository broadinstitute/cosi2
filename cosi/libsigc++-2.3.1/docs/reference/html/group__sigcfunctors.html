<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libsigc++: Functors</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libsigc++
   &#160;<span id="projectnumber">2.3.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> </div>
  <div class="headertitle">
<div class="title">Functors</div> </div>
</div><!--header-->
<div class="contents">

<p>Functors are copyable types that define operator()(). <a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__slot"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__slot.html">Slots</a></td></tr>
<tr class="memdesc:group__slot"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slots are type-safe representations of callback methods and functions. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__mem__fun"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mem__fun.html">mem_fun()</a></td></tr>
<tr class="memdesc:group__mem__fun"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__mem__fun.html#ga52244864d2f65f072678b682bfc9913f" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">mem_fun()</a> is used to convert a pointer to a method to a functor. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__ptr__fun"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html">ptr_fun()</a></td></tr>
<tr class="memdesc:group__ptr__fun"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__ptr__fun.html#ga9c80de72f656fb05e81fda622dddc863" title="Creates a functor of type sigc::pointer_functor0 which wraps an existing non-member function...">ptr_fun()</a> is used to convert a pointer to a function to a functor. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__base.html">sigc::functor_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hint to the compiler. <a href="structsigc_1_1functor__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__trait.html">sigc::functor_trait&lt; T_functor, I_derives_functor_base &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait that specifies the return type of any type. <a href="structsigc_1_1functor__trait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga93b6ee8815d90adccfdceed72bcda577"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sigcfunctors.html#ga93b6ee8815d90adccfdceed72bcda577">SIGC_FUNCTORS_HAVE_RESULT_TYPE</a></td></tr>
<tr class="memdesc:ga93b6ee8815d90adccfdceed72bcda577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro, if you want to mix user-defined and third party functors with libsigc++. <a href="#ga93b6ee8815d90adccfdceed72bcda577"></a><br/></td></tr>
<tr class="separator:ga93b6ee8815d90adccfdceed72bcda577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a6f5575dc0b0ea896889c782721f6be"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sigcfunctors.html#ga7a6f5575dc0b0ea896889c782721f6be">SIGC_FUNCTOR_TRAIT</a>(T_functor, T_return)</td></tr>
<tr class="memdesc:ga7a6f5575dc0b0ea896889c782721f6be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro, if you want to mix user-defined and third party functors with libsigc++. <a href="#ga7a6f5575dc0b0ea896889c782721f6be"></a><br/></td></tr>
<tr class="separator:ga7a6f5575dc0b0ea896889c782721f6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf1ba3cacb09cc5c3c3e399836ec6e50"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sigcfunctors.html#gadf1ba3cacb09cc5c3c3e399836ec6e50">SIGC_FUNCTORS_DEDUCE_RESULT_TYPE_WITH_DECLTYPE</a></td></tr>
<tr class="memdesc:gadf1ba3cacb09cc5c3c3e399836ec6e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro, if you want to mix user-defined and third party functors with libsigc++. <a href="#gadf1ba3cacb09cc5c3c3e399836ec6e50"></a><br/></td></tr>
<tr class="separator:gadf1ba3cacb09cc5c3c3e399836ec6e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga64cb7832acc1e58efb5ffe0b4f5e9404"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_functor &gt; </td></tr>
<tr class="memitem:ga64cb7832acc1e58efb5ffe0b4f5e9404"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404">sigc::visit_each</a> (const T_action&amp; _A_action, const T_functor&amp; _A_functor)</td></tr>
<tr class="memdesc:ga64cb7832acc1e58efb5ffe0b4f5e9404"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs a functor on each of the targets of a functor. <a href="#ga64cb7832acc1e58efb5ffe0b4f5e9404"></a><br/></td></tr>
<tr class="separator:ga64cb7832acc1e58efb5ffe0b4f5e9404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada222d975b87d64cfa7a7f29244ae587"><td class="memTemplParams" colspan="2"><a class="anchor" id="gada222d975b87d64cfa7a7f29244ae587"></a>
template &lt;class T_type , class T_action , class T_functor &gt; </td></tr>
<tr class="memitem:gada222d975b87d64cfa7a7f29244ae587"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sigcfunctors.html#gada222d975b87d64cfa7a7f29244ae587">sigc::visit_each_type</a> (const T_action&amp; _A_action, const T_functor&amp; _A_functor)</td></tr>
<tr class="memdesc:gada222d975b87d64cfa7a7f29244ae587"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs a functor on each of the targets of a functor limited to a restricted type. <br/></td></tr>
<tr class="separator:gada222d975b87d64cfa7a7f29244ae587"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Functors are copyable types that define operator()(). </p>
<p>Types that define operator()() overloads with different return types are referred to as multi-type functors. Multi-type functors are only partially supported in libsigc++.</p>
<p>Closures are functors that store all information needed to invoke a callback from operator()().</p>
<p>Adaptors are functors that alter the signature of a functor's operator()().</p>
<p>libsigc++ defines numerous functors, closures and adaptors. Since libsigc++ is a callback library, most functors are also closures. The documentation doesn't distinguish between functors and closures.</p>
<p>The basic functor types libsigc++ provides are created with <a class="el" href="group__ptr__fun.html#ga9c80de72f656fb05e81fda622dddc863" title="Creates a functor of type sigc::pointer_functor0 which wraps an existing non-member function...">ptr_fun()</a> and <a class="el" href="group__mem__fun.html#ga52244864d2f65f072678b682bfc9913f" title="Creates a functor of type sigc::mem_functor0 which wraps a method.">mem_fun()</a> and can be converted into slots implicitly. The set of adaptors that ships with libsigc++ is documented in the <a class="el" href="group__adaptors.html">Adaptors</a> module.</p>
<p>If you want to mix user-defined and third party functors with libsigc++, and you want them to be implicitly convertible into slots, libsigc++ must know the result type of your functors. There are different ways to achieve that.</p>
<ul>
<li>Derive your functors from <a class="el" href="structsigc_1_1functor__base.html" title="A hint to the compiler.">sigc::functor_base</a> and place <code>typedef T_return result_type;</code> in the class definition.</li>
<li>Use the macro <a class="el" href="group__sigcfunctors.html#ga7a6f5575dc0b0ea896889c782721f6be" title="Helper macro, if you want to mix user-defined and third party functors with libsigc++.">SIGC_FUNCTOR_TRAIT(T_functor,T_return)</a> in namespace sigc. Multi-type functors are only partly supported.</li>
<li>Use the macro <a class="el" href="group__sigcfunctors.html#ga93b6ee8815d90adccfdceed72bcda577" title="Helper macro, if you want to mix user-defined and third party functors with libsigc++.">SIGC_FUNCTORS_HAVE_RESULT_TYPE</a>, if you want libsigc++ to assume that result_type is defined in all user-defined or third party functors, except those for which you specify a return type explicitly with <a class="el" href="group__sigcfunctors.html#ga7a6f5575dc0b0ea896889c782721f6be" title="Helper macro, if you want to mix user-defined and third party functors with libsigc++.">SIGC_FUNCTOR_TRAIT()</a>.</li>
<li>Use the macro <a class="el" href="group__sigcfunctors.html#gadf1ba3cacb09cc5c3c3e399836ec6e50" title="Helper macro, if you want to mix user-defined and third party functors with libsigc++.">SIGC_FUNCTORS_DEDUCE_RESULT_TYPE_WITH_DECLTYPE</a>, if your compiler makes it possible. Functors with overloaded operator()() are not supported.</li>
</ul>
<p>The last alterative makes it possible to construct a slot from a C++11 lambda expression with any return type. Example: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>sigc {</div>
<div class="line"> <a class="code" href="group__sigcfunctors.html#gadf1ba3cacb09cc5c3c3e399836ec6e50" title="Helper macro, if you want to mix user-defined and third party functors with libsigc++.">SIGC_FUNCTORS_DEDUCE_RESULT_TYPE_WITH_DECLTYPE</a></div>
<div class="line">}</div>
<div class="line"><a class="code" href="classsigc_1_1slot.html" title="Convenience wrapper for the numbered sigc::slot# templates.">sigc::slot&lt;bool, int&gt;</a> slot1 = [](<span class="keywordtype">int</span> n)-&gt; <span class="keywordtype">bool</span></div>
<div class="line"> {</div>
<div class="line"> <span class="keywordflow">return</span> n == 42;</div>
<div class="line"> };</div>
</div><!-- fragment --> <h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga7a6f5575dc0b0ea896889c782721f6be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIGC_FUNCTOR_TRAIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T_functor, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T_return&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro, if you want to mix user-defined and third party functors with libsigc++. </p>
<p>If you want to mix functors not derived from <a class="el" href="structsigc_1_1functor__base.html" title="A hint to the compiler.">sigc::functor_base</a> with libsigc++, and these functors don't define <code>result_type</code>, use this macro inside namespace sigc to expose the return type of the functors like so: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>sigc {</div>
<div class="line"> <a class="code" href="group__sigcfunctors.html#ga7a6f5575dc0b0ea896889c782721f6be" title="Helper macro, if you want to mix user-defined and third party functors with libsigc++.">SIGC_FUNCTOR_TRAIT</a>(first_functor_type, return_type_of_first_functor_type)</div>
<div class="line"> <a class="code" href="group__sigcfunctors.html#ga7a6f5575dc0b0ea896889c782721f6be" title="Helper macro, if you want to mix user-defined and third party functors with libsigc++.">SIGC_FUNCTOR_TRAIT</a>(second_functor_type, return_type_of_second_functor_type)</div>
<div class="line"> ...</div>
<div class="line">}</div>
</div><!-- fragment --> </div>
</div>
<a class="anchor" id="gadf1ba3cacb09cc5c3c3e399836ec6e50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIGC_FUNCTORS_DEDUCE_RESULT_TYPE_WITH_DECLTYPE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro, if you want to mix user-defined and third party functors with libsigc++. </p>
<p>If you want to mix functors not derived from <a class="el" href="structsigc_1_1functor__base.html" title="A hint to the compiler.">sigc::functor_base</a> with libsigc++, and your compiler can deduce the result type of the functor with the C++11 keyword <code>decltype</code>, use this macro inside namespace sigc like so: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>sigc {</div>
<div class="line"> <a class="code" href="group__sigcfunctors.html#gadf1ba3cacb09cc5c3c3e399836ec6e50" title="Helper macro, if you want to mix user-defined and third party functors with libsigc++.">SIGC_FUNCTORS_DEDUCE_RESULT_TYPE_WITH_DECLTYPE</a></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="since_2_2_11"><dt><b><a class="el" href="since_2_2_11.html#_since_2_2_11000001">Since libsigc++ 2.2.11:</a></b></dt><dd></dd></dl>
<p>You can't use both SIGC_FUNCTORS_HAVE_RESULT_TYPE and SIGC_FUNCTORS_DEDUCE_RESULT_TYPE_WITH_DECLTYPE in the same compilation unit. </p>

</div>
</div>
<a class="anchor" id="ga93b6ee8815d90adccfdceed72bcda577"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIGC_FUNCTORS_HAVE_RESULT_TYPE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro, if you want to mix user-defined and third party functors with libsigc++. </p>
<p>If you want to mix functors not derived from <a class="el" href="structsigc_1_1functor__base.html" title="A hint to the compiler.">sigc::functor_base</a> with libsigc++, and these functors define <code>result_type</code>, use this macro inside namespace sigc like so: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>sigc { <a class="code" href="group__sigcfunctors.html#ga93b6ee8815d90adccfdceed72bcda577" title="Helper macro, if you want to mix user-defined and third party functors with libsigc++.">SIGC_FUNCTORS_HAVE_RESULT_TYPE</a> }</div>
</div><!-- fragment --><p>You can't use both SIGC_FUNCTORS_HAVE_RESULT_TYPE and SIGC_FUNCTORS_DEDUCE_RESULT_TYPE_WITH_DECLTYPE in the same compilation unit. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga64cb7832acc1e58efb5ffe0b4f5e9404"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_functor &amp;&#160;</td>
          <td class="paramname"><em>_A_functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs a functor on each of the targets of a functor. </p>
<p>All unknown types just call <em>_A_action</em> on them. Add overloads that specialize the <em>T_functor</em> argument for your own functor types, so that subobjects get visited. This is needed to enable auto-disconnection support for your functor types.</p>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><span class="keyword">struct </span>some_functor</div>
<div class="line">{</div>
<div class="line"> <span class="keywordtype">void</span> operator()() {}</div>
<div class="line"> some_possibly_sigc_trackable_derived_type some_data_member;</div>
<div class="line"> some_other_functor_type some_other_functor;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>sigc</div>
<div class="line">{</div>
<div class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> T_action&gt;</div>
<div class="line"> <span class="keywordtype">void</span> <a class="code" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404" title="This function performs a functor on each of the targets of a functor.">visit_each</a>(<span class="keyword">const</span> T_action&amp; _A_action,</div>
<div class="line"> <span class="keyword">const</span> some_functor&amp; _A_target)</div>
<div class="line"> {</div>
<div class="line"> <a class="code" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404" title="This function performs a functor on each of the targets of a functor.">visit_each</a>(_A_action, _A_target.some_data_member);</div>
<div class="line"> <a class="code" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404" title="This function performs a functor on each of the targets of a functor.">visit_each</a>(_A_action, _A_target.some_other_functor);</div>
<div class="line"> }</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 18 2012 09:28:24 for libsigc++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
