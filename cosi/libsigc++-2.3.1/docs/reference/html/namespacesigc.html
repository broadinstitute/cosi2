<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libsigc++: sigc Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libsigc++
   &#160;<span id="projectnumber">2.3.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> </div>
  <div class="headertitle">
<div class="title">sigc Namespace Reference</div> </div>
</div><!--header-->
<div class="contents">

<p>The libsigc++ namespace. <a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1connection.html">connection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convinience class for safe disconnection. <a href="structsigc_1_1connection.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1reference__wrapper.html">reference_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference wrapper. <a href="structsigc_1_1reference__wrapper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1const__reference__wrapper.html">const_reference_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const reference wrapper. <a href="structsigc_1_1const__reference__wrapper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1signal__base.html">signal_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for the <a class="el" href="classsigc_1_1signal.html" title="Convenience wrapper for the numbered sigc::signal# templates.">sigc::signal</a># templates. <a href="structsigc_1_1signal__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1trackable.html">trackable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for objects with auto-disconnection. <a href="structsigc_1_1trackable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1is__base__and__derived.html">is_base_and_derived</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time determination of base-class relationship in C++ (adapted to match the syntax of boost's type_traits library). <a href="structsigc_1_1is__base__and__derived.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__argument.html">bound_argument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bound_argument&lt;Foo&gt; object stores a bound (for instance, with <a class="el" href="group__bind.html#ga2f099bc6056b32f2a58134ba8537c6f4" title="Creates an adaptor of type sigc::bind_functor which binds the passed argument to the passed functor...">sigc::bind()</a>, or <a class="el" href="group__bind.html#gaca1ae2466988d67d00a5f2cd16c8d90a" title="Creates an adaptor of type sigc::bind_return_functor which fixes the return value of the passed funct...">sigc::bind_return()</a>) argument. <a href="classsigc_1_1bound__argument.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__argument_3_01reference__wrapper_3_01T__wrapped_01_4_01_4.html">bound_argument&lt; reference_wrapper&lt; T_wrapped &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__argument.html" title="A bound_argument&lt;Foo&gt; object stores a bound (for instance, with sigc::bind(), or sigc::bind_return())...">bound_argument</a> object for a bound argument that is passed by <a class="el" href="group__bind.html#ga2f099bc6056b32f2a58134ba8537c6f4" title="Creates an adaptor of type sigc::bind_functor which binds the passed argument to the passed functor...">bind()</a> or returned by <a class="el" href="group__bind.html#gaca1ae2466988d67d00a5f2cd16c8d90a" title="Creates an adaptor of type sigc::bind_return_functor which fixes the return value of the passed funct...">bind_return()</a> by reference, specialized for reference_wrapper&lt;&gt; types. <a href="classsigc_1_1bound__argument_3_01reference__wrapper_3_01T__wrapped_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__argument_3_01const__reference__wrapper_3_01T__wrapped_01_4_01_4.html">bound_argument&lt; const_reference_wrapper&lt; T_wrapped &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__argument.html" title="A bound_argument&lt;Foo&gt; object stores a bound (for instance, with sigc::bind(), or sigc::bind_return())...">bound_argument</a> object for a bound argument that is passed by <a class="el" href="group__bind.html#ga2f099bc6056b32f2a58134ba8537c6f4" title="Creates an adaptor of type sigc::bind_functor which binds the passed argument to the passed functor...">bind()</a> or returned by <a class="el" href="group__bind.html#gaca1ae2466988d67d00a5f2cd16c8d90a" title="Creates an adaptor of type sigc::bind_return_functor which fixes the return value of the passed funct...">bind_return()</a> by const reference, specialized for const reference_wrapper&lt;&gt; types. <a href="classsigc_1_1bound__argument_3_01const__reference__wrapper_3_01T__wrapped_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot__base.html">slot_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for slots. <a href="classsigc_1_1slot__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1slot__iterator.html">slot_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-style iterator for <a class="el" href="structsigc_1_1slot__list.html" title="STL-style list interface for sigc::signal#.">slot_list</a>. <a href="structsigc_1_1slot__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1slot__const__iterator.html">slot_const_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-style const iterator for <a class="el" href="structsigc_1_1slot__list.html" title="STL-style list interface for sigc::signal#.">slot_list</a>. <a href="structsigc_1_1slot__const__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1slot__list.html">slot_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-style list interface for <a class="el" href="classsigc_1_1signal.html" title="Convenience wrapper for the numbered sigc::signal# templates.">sigc::signal</a>#. <a href="structsigc_1_1slot__list.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal0.html">signal0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal declaration. <a href="classsigc_1_1signal0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal1.html">signal1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal declaration. <a href="classsigc_1_1signal1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal2.html">signal2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal declaration. <a href="classsigc_1_1signal2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal3.html">signal3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal declaration. <a href="classsigc_1_1signal3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal4.html">signal4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal declaration. <a href="classsigc_1_1signal4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal5.html">signal5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal declaration. <a href="classsigc_1_1signal5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal6.html">signal6</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal declaration. <a href="classsigc_1_1signal6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal7.html">signal7</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal declaration. <a href="classsigc_1_1signal7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal.html">signal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal.html" title="Convenience wrapper for the numbered sigc::signal# templates.">sigc::signal</a># templates. <a href="classsigc_1_1signal.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal_3_01T__return_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">signal&lt; T_return, nil, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal0.html" title="Signal declaration.">sigc::signal0</a> template. <a href="classsigc_1_1signal_3_01T__return_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">signal&lt; T_return, T_arg1, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal1.html" title="Signal declaration.">sigc::signal1</a> template. <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">signal&lt; T_return, T_arg1, T_arg2, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal2.html" title="Signal declaration.">sigc::signal2</a> template. <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">signal&lt; T_return, T_arg1, T_arg2, T_arg3, nil, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal3.html" title="Signal declaration.">sigc::signal3</a> template. <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01nil_00_01nil_00_01nil_01_4.html">signal&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal4.html" title="Signal declaration.">sigc::signal4</a> template. <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01nil_00_01nil_01_4.html">signal&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal5.html" title="Signal declaration.">sigc::signal5</a> template. <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6_00_01nil_01_4.html">signal&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal6.html" title="Signal declaration.">sigc::signal6</a> template. <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1limit__reference.html">limit_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection.">sigc::trackable</a>, then <a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404" title="This function performs a functor on each of the targets of a functor.">visit_each&lt;&gt;()</a> will "limit" itself to the <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection.">sigc::trackable</a> reference instead of the derived reference. <a href="classsigc_1_1limit__reference.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1limit__reference_3_01T__type_00_01true_01_4.html">limit_reference&lt; T_type, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1limit__reference.html" title="A limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from sig...">limit_reference</a> object for a class that derives from trackable. <a href="classsigc_1_1limit__reference_3_01T__type_00_01true_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__limit__reference.html">const_limit_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection.">sigc::trackable</a>, then <a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404" title="This function performs a functor on each of the targets of a functor.">visit_each&lt;&gt;()</a> will "limit" itself to the <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection.">sigc::trackable</a> reference instead of the derived reference. <a href="classsigc_1_1const__limit__reference.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__limit__reference_3_01T__type_00_01true_01_4.html">const_limit_reference&lt; T_type, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__limit__reference.html" title="A const_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from sigc::trackable, then visit_each&lt;&gt;() will &quot;limit&quot; itself to the sigc::trackable reference instead of the derived reference.">const_limit_reference</a> object for a class that derives from trackable. <a href="classsigc_1_1const__limit__reference_3_01T__type_00_01true_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__limit__reference.html">volatile_limit_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A volatile_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection.">sigc::trackable</a>, then <a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404" title="This function performs a functor on each of the targets of a functor.">visit_each&lt;&gt;()</a> will "limit" itself to the <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection.">sigc::trackable</a> reference instead of the derived reference. <a href="classsigc_1_1volatile__limit__reference.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__limit__reference_3_01T__type_00_01true_01_4.html">volatile_limit_reference&lt; T_type, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__limit__reference.html" title="A volatile_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from sigc::trackable, then visit_each&lt;&gt;() will &quot;limit&quot; itself to the sigc::trackable reference instead of the derived reference.">volatile_limit_reference</a> object for a class that derives from trackable. <a href="classsigc_1_1volatile__limit__reference_3_01T__type_00_01true_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__limit__reference.html">const_volatile_limit_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const_volatile_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection.">sigc::trackable</a>, then <a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404" title="This function performs a functor on each of the targets of a functor.">visit_each&lt;&gt;()</a> will "limit" itself to the <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection.">sigc::trackable</a> reference instead of the derived reference. <a href="classsigc_1_1const__volatile__limit__reference.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__limit__reference_3_01T__type_00_01true_01_4.html">const_volatile_limit_reference&lt; T_type, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__limit__reference.html" title="A const_volatile_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that...">const_volatile_limit_reference</a> object for a class that derives from trackable. <a href="classsigc_1_1const__volatile__limit__reference_3_01T__type_00_01true_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__base.html">functor_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hint to the compiler. <a href="structsigc_1_1functor__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__trait.html">functor_trait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait that specifies the return type of any type. <a href="structsigc_1_1functor__trait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot0.html">slot0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. <a href="classsigc_1_1slot0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot1.html">slot1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. <a href="classsigc_1_1slot1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot2.html">slot2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. <a href="classsigc_1_1slot2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot3.html">slot3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. <a href="classsigc_1_1slot3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot4.html">slot4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. <a href="classsigc_1_1slot4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot5.html">slot5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. <a href="classsigc_1_1slot5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot6.html">slot6</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. <a href="classsigc_1_1slot6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot7.html">slot7</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque. <a href="classsigc_1_1slot7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot.html">slot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot.html" title="Convenience wrapper for the numbered sigc::slot# templates.">sigc::slot</a># templates. <a href="classsigc_1_1slot.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot_3_01T__return_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">slot&lt; T_return, nil, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot0.html" title="Converts an arbitrary functor to a unified type which is opaque.">sigc::slot0</a> template. <a href="classsigc_1_1slot_3_01T__return_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">slot&lt; T_return, T_arg1, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot1.html" title="Converts an arbitrary functor to a unified type which is opaque.">sigc::slot1</a> template. <a href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">slot&lt; T_return, T_arg1, T_arg2, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot2.html" title="Converts an arbitrary functor to a unified type which is opaque.">sigc::slot2</a> template. <a href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">slot&lt; T_return, T_arg1, T_arg2, T_arg3, nil, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot3.html" title="Converts an arbitrary functor to a unified type which is opaque.">sigc::slot3</a> template. <a href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01nil_00_01nil_00_01nil_01_4.html">slot&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot4.html" title="Converts an arbitrary functor to a unified type which is opaque.">sigc::slot4</a> template. <a href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01nil_00_01nil_01_4.html">slot&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot5.html" title="Converts an arbitrary functor to a unified type which is opaque.">sigc::slot5</a> template. <a href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6_00_01nil_01_4.html">slot&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot6.html" title="Converts an arbitrary functor to a unified type which is opaque.">sigc::slot6</a> template. <a href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor0.html">pointer_functor0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor0.html" title="pointer_functor0 wraps existing non-member functions with 0 argument(s).">pointer_functor0</a> wraps existing non-member functions with 0 argument(s). <a href="classsigc_1_1pointer__functor0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor1.html">pointer_functor1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor1.html" title="pointer_functor1 wraps existing non-member functions with 1 argument(s).">pointer_functor1</a> wraps existing non-member functions with 1 argument(s). <a href="classsigc_1_1pointer__functor1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor2.html">pointer_functor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor2.html" title="pointer_functor2 wraps existing non-member functions with 2 argument(s).">pointer_functor2</a> wraps existing non-member functions with 2 argument(s). <a href="classsigc_1_1pointer__functor2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor3.html">pointer_functor3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor3.html" title="pointer_functor3 wraps existing non-member functions with 3 argument(s).">pointer_functor3</a> wraps existing non-member functions with 3 argument(s). <a href="classsigc_1_1pointer__functor3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor4.html">pointer_functor4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor4.html" title="pointer_functor4 wraps existing non-member functions with 4 argument(s).">pointer_functor4</a> wraps existing non-member functions with 4 argument(s). <a href="classsigc_1_1pointer__functor4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor5.html">pointer_functor5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor5.html" title="pointer_functor5 wraps existing non-member functions with 5 argument(s).">pointer_functor5</a> wraps existing non-member functions with 5 argument(s). <a href="classsigc_1_1pointer__functor5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor6.html">pointer_functor6</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor6.html" title="pointer_functor6 wraps existing non-member functions with 6 argument(s).">pointer_functor6</a> wraps existing non-member functions with 6 argument(s). <a href="classsigc_1_1pointer__functor6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor7.html">pointer_functor7</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor7.html" title="pointer_functor7 wraps existing non-member functions with 7 argument(s).">pointer_functor7</a> wraps existing non-member functions with 7 argument(s). <a href="classsigc_1_1pointer__functor7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor0.html" title="mem_functor0 wraps methods with 0 argument(s).">mem_functor0</a> wraps methods with 0 argument(s). <a href="classsigc_1_1mem__functor0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor1.html" title="mem_functor1 wraps methods with 1 argument(s).">mem_functor1</a> wraps methods with 1 argument(s). <a href="classsigc_1_1mem__functor1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor2.html" title="mem_functor2 wraps methods with 2 argument(s).">mem_functor2</a> wraps methods with 2 argument(s). <a href="classsigc_1_1mem__functor2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor3.html" title="mem_functor3 wraps methods with 3 argument(s).">mem_functor3</a> wraps methods with 3 argument(s). <a href="classsigc_1_1mem__functor3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor4.html" title="mem_functor4 wraps methods with 4 argument(s).">mem_functor4</a> wraps methods with 4 argument(s). <a href="classsigc_1_1mem__functor4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor5.html" title="mem_functor5 wraps methods with 5 argument(s).">mem_functor5</a> wraps methods with 5 argument(s). <a href="classsigc_1_1mem__functor5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor6.html" title="mem_functor6 wraps methods with 6 argument(s).">mem_functor6</a> wraps methods with 6 argument(s). <a href="classsigc_1_1mem__functor6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor7.html" title="mem_functor7 wraps methods with 7 argument(s).">mem_functor7</a> wraps methods with 7 argument(s). <a href="classsigc_1_1mem__functor7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor0.html">const_mem_functor0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor0.html" title="const_mem_functor0 wraps const methods with 0 argument(s).">const_mem_functor0</a> wraps const methods with 0 argument(s). <a href="classsigc_1_1const__mem__functor0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor1.html">const_mem_functor1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor1.html" title="const_mem_functor1 wraps const methods with 1 argument(s).">const_mem_functor1</a> wraps const methods with 1 argument(s). <a href="classsigc_1_1const__mem__functor1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor2.html">const_mem_functor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor2.html" title="const_mem_functor2 wraps const methods with 2 argument(s).">const_mem_functor2</a> wraps const methods with 2 argument(s). <a href="classsigc_1_1const__mem__functor2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor3.html">const_mem_functor3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor3.html" title="const_mem_functor3 wraps const methods with 3 argument(s).">const_mem_functor3</a> wraps const methods with 3 argument(s). <a href="classsigc_1_1const__mem__functor3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor4.html">const_mem_functor4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor4.html" title="const_mem_functor4 wraps const methods with 4 argument(s).">const_mem_functor4</a> wraps const methods with 4 argument(s). <a href="classsigc_1_1const__mem__functor4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor5.html">const_mem_functor5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor5.html" title="const_mem_functor5 wraps const methods with 5 argument(s).">const_mem_functor5</a> wraps const methods with 5 argument(s). <a href="classsigc_1_1const__mem__functor5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor6.html">const_mem_functor6</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor6.html" title="const_mem_functor6 wraps const methods with 6 argument(s).">const_mem_functor6</a> wraps const methods with 6 argument(s). <a href="classsigc_1_1const__mem__functor6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor7.html">const_mem_functor7</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor7.html" title="const_mem_functor7 wraps const methods with 7 argument(s).">const_mem_functor7</a> wraps const methods with 7 argument(s). <a href="classsigc_1_1const__mem__functor7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor0.html">volatile_mem_functor0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor0.html" title="volatile_mem_functor0 wraps volatile methods with 0 argument(s).">volatile_mem_functor0</a> wraps volatile methods with 0 argument(s). <a href="classsigc_1_1volatile__mem__functor0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor1.html">volatile_mem_functor1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor1.html" title="volatile_mem_functor1 wraps volatile methods with 1 argument(s).">volatile_mem_functor1</a> wraps volatile methods with 1 argument(s). <a href="classsigc_1_1volatile__mem__functor1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor2.html">volatile_mem_functor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor2.html" title="volatile_mem_functor2 wraps volatile methods with 2 argument(s).">volatile_mem_functor2</a> wraps volatile methods with 2 argument(s). <a href="classsigc_1_1volatile__mem__functor2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor3.html">volatile_mem_functor3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor3.html" title="volatile_mem_functor3 wraps volatile methods with 3 argument(s).">volatile_mem_functor3</a> wraps volatile methods with 3 argument(s). <a href="classsigc_1_1volatile__mem__functor3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor4.html">volatile_mem_functor4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor4.html" title="volatile_mem_functor4 wraps volatile methods with 4 argument(s).">volatile_mem_functor4</a> wraps volatile methods with 4 argument(s). <a href="classsigc_1_1volatile__mem__functor4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor5.html">volatile_mem_functor5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor5.html" title="volatile_mem_functor5 wraps volatile methods with 5 argument(s).">volatile_mem_functor5</a> wraps volatile methods with 5 argument(s). <a href="classsigc_1_1volatile__mem__functor5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor6.html">volatile_mem_functor6</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor6.html" title="volatile_mem_functor6 wraps volatile methods with 6 argument(s).">volatile_mem_functor6</a> wraps volatile methods with 6 argument(s). <a href="classsigc_1_1volatile__mem__functor6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor7.html">volatile_mem_functor7</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor7.html" title="volatile_mem_functor7 wraps volatile methods with 7 argument(s).">volatile_mem_functor7</a> wraps volatile methods with 7 argument(s). <a href="classsigc_1_1volatile__mem__functor7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">const_volatile_mem_functor0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor0.html" title="const_volatile_mem_functor0 wraps const volatile methods with 0 argument(s).">const_volatile_mem_functor0</a> wraps const volatile methods with 0 argument(s). <a href="classsigc_1_1const__volatile__mem__functor0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">const_volatile_mem_functor1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor1.html" title="const_volatile_mem_functor1 wraps const volatile methods with 1 argument(s).">const_volatile_mem_functor1</a> wraps const volatile methods with 1 argument(s). <a href="classsigc_1_1const__volatile__mem__functor1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">const_volatile_mem_functor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor2.html" title="const_volatile_mem_functor2 wraps const volatile methods with 2 argument(s).">const_volatile_mem_functor2</a> wraps const volatile methods with 2 argument(s). <a href="classsigc_1_1const__volatile__mem__functor2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">const_volatile_mem_functor3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor3.html" title="const_volatile_mem_functor3 wraps const volatile methods with 3 argument(s).">const_volatile_mem_functor3</a> wraps const volatile methods with 3 argument(s). <a href="classsigc_1_1const__volatile__mem__functor3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">const_volatile_mem_functor4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor4.html" title="const_volatile_mem_functor4 wraps const volatile methods with 4 argument(s).">const_volatile_mem_functor4</a> wraps const volatile methods with 4 argument(s). <a href="classsigc_1_1const__volatile__mem__functor4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">const_volatile_mem_functor5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor5.html" title="const_volatile_mem_functor5 wraps const volatile methods with 5 argument(s).">const_volatile_mem_functor5</a> wraps const volatile methods with 5 argument(s). <a href="classsigc_1_1const__volatile__mem__functor5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">const_volatile_mem_functor6</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor6.html" title="const_volatile_mem_functor6 wraps const volatile methods with 6 argument(s).">const_volatile_mem_functor6</a> wraps const volatile methods with 6 argument(s). <a href="classsigc_1_1const__volatile__mem__functor6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">const_volatile_mem_functor7</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor7.html" title="const_volatile_mem_functor7 wraps const volatile methods with 7 argument(s).">const_volatile_mem_functor7</a> wraps const volatile methods with 7 argument(s). <a href="classsigc_1_1const__volatile__mem__functor7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance.">bound_mem_functor0</a> encapsulates a method with 0 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance.">bound_mem_functor1</a> encapsulates a method with 1 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance.">bound_mem_functor2</a> encapsulates a method with 2 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance.">bound_mem_functor3</a> encapsulates a method with 3 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance.">bound_mem_functor4</a> encapsulates a method with 4 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance.">bound_mem_functor5</a> encapsulates a method with 5 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance.">bound_mem_functor6</a> encapsulates a method with 6 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance.">bound_mem_functor7</a> encapsulates a method with 7 arguments and an object instance. <a href="classsigc_1_1bound__mem__functor7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html" title="bound_const_mem_functor0 encapsulates a const method with 0 arguments and an object instance...">bound_const_mem_functor0</a> encapsulates a const method with 0 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html" title="bound_const_mem_functor1 encapsulates a const method with 1 arguments and an object instance...">bound_const_mem_functor1</a> encapsulates a const method with 1 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html" title="bound_const_mem_functor2 encapsulates a const method with 2 arguments and an object instance...">bound_const_mem_functor2</a> encapsulates a const method with 2 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html" title="bound_const_mem_functor3 encapsulates a const method with 3 arguments and an object instance...">bound_const_mem_functor3</a> encapsulates a const method with 3 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html" title="bound_const_mem_functor4 encapsulates a const method with 4 arguments and an object instance...">bound_const_mem_functor4</a> encapsulates a const method with 4 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html" title="bound_const_mem_functor5 encapsulates a const method with 5 arguments and an object instance...">bound_const_mem_functor5</a> encapsulates a const method with 5 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html" title="bound_const_mem_functor6 encapsulates a const method with 6 arguments and an object instance...">bound_const_mem_functor6</a> encapsulates a const method with 6 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html" title="bound_const_mem_functor7 encapsulates a const method with 7 arguments and an object instance...">bound_const_mem_functor7</a> encapsulates a const method with 7 arguments and an object instance. <a href="classsigc_1_1bound__const__mem__functor7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html" title="bound_volatile_mem_functor0 encapsulates a volatile method with 0 arguments and an object instance...">bound_volatile_mem_functor0</a> encapsulates a volatile method with 0 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html" title="bound_volatile_mem_functor1 encapsulates a volatile method with 1 arguments and an object instance...">bound_volatile_mem_functor1</a> encapsulates a volatile method with 1 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html" title="bound_volatile_mem_functor2 encapsulates a volatile method with 2 arguments and an object instance...">bound_volatile_mem_functor2</a> encapsulates a volatile method with 2 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html" title="bound_volatile_mem_functor3 encapsulates a volatile method with 3 arguments and an object instance...">bound_volatile_mem_functor3</a> encapsulates a volatile method with 3 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html" title="bound_volatile_mem_functor4 encapsulates a volatile method with 4 arguments and an object instance...">bound_volatile_mem_functor4</a> encapsulates a volatile method with 4 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html" title="bound_volatile_mem_functor5 encapsulates a volatile method with 5 arguments and an object instance...">bound_volatile_mem_functor5</a> encapsulates a volatile method with 5 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html" title="bound_volatile_mem_functor6 encapsulates a volatile method with 6 arguments and an object instance...">bound_volatile_mem_functor6</a> encapsulates a volatile method with 6 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html" title="bound_volatile_mem_functor7 encapsulates a volatile method with 7 arguments and an object instance...">bound_volatile_mem_functor7</a> encapsulates a volatile method with 7 arguments and an object instance. <a href="classsigc_1_1bound__volatile__mem__functor7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html" title="bound_const_volatile_mem_functor0 encapsulates a const volatile method with 0 arguments and an object...">bound_const_volatile_mem_functor0</a> encapsulates a const volatile method with 0 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html" title="bound_const_volatile_mem_functor1 encapsulates a const volatile method with 1 arguments and an object...">bound_const_volatile_mem_functor1</a> encapsulates a const volatile method with 1 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html" title="bound_const_volatile_mem_functor2 encapsulates a const volatile method with 2 arguments and an object...">bound_const_volatile_mem_functor2</a> encapsulates a const volatile method with 2 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html" title="bound_const_volatile_mem_functor3 encapsulates a const volatile method with 3 arguments and an object...">bound_const_volatile_mem_functor3</a> encapsulates a const volatile method with 3 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html" title="bound_const_volatile_mem_functor4 encapsulates a const volatile method with 4 arguments and an object...">bound_const_volatile_mem_functor4</a> encapsulates a const volatile method with 4 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html" title="bound_const_volatile_mem_functor5 encapsulates a const volatile method with 5 arguments and an object...">bound_const_volatile_mem_functor5</a> encapsulates a const volatile method with 5 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html" title="bound_const_volatile_mem_functor6 encapsulates a const volatile method with 6 arguments and an object...">bound_const_volatile_mem_functor6</a> encapsulates a const volatile method with 6 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html" title="bound_const_volatile_mem_functor7 encapsulates a const volatile method with 7 arguments and an object...">bound_const_volatile_mem_functor7</a> encapsulates a const volatile method with 7 arguments and an object instance. <a href="classsigc_1_1bound__const__volatile__mem__functor7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1adaptor__base.html">adaptor_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hint to the compiler. <a href="structsigc_1_1adaptor__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1deduce__result__type.html">deduce_result_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce the return type of a functor. <a href="structsigc_1_1deduce__result__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01void_00_01void_00_01void_00_01void_00_01vdb2f9f83b3eba2baeb19678a790211a3.html">deduce_result_type&lt; T_functor, void, void, void, void, void, void, void, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce the return type of a functor. <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01void_00_01void_00_01void_00_01void_00_01vdb2f9f83b3eba2baeb19678a790211a3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01void_00_01void_00_01void_00_f4c559613b292c7b689426d5c155df15.html">deduce_result_type&lt; T_functor, T_arg1, void, void, void, void, void, void, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce the return type of a functor. <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01void_00_01void_00_01void_00_f4c559613b292c7b689426d5c155df15.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01void_00_01void_724dd7c759e838f48e6fa6545d8e015d.html">deduce_result_type&lt; T_functor, T_arg1, T_arg2, void, void, void, void, void, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce the return type of a functor. <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01void_00_01void_724dd7c759e838f48e6fa6545d8e015d.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01vo258d7260cbbb4e192063ff2984a0677a.html">deduce_result_type&lt; T_functor, T_arg1, T_arg2, T_arg3, void, void, void, void, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce the return type of a functor. <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01vo258d7260cbbb4e192063ff2984a0677a.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T_9b37fe7be1f2633448bc6b77ab8f97ff.html">deduce_result_type&lt; T_functor, T_arg1, T_arg2, T_arg3, T_arg4, void, void, void, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce the return type of a functor. <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T_9b37fe7be1f2633448bc6b77ab8f97ff.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T_d8ef7847af7e7170bed8f3a632586811.html">deduce_result_type&lt; T_functor, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, void, void, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce the return type of a functor. <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T_d8ef7847af7e7170bed8f3a632586811.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T_4788a98c68901ad51b4daf97aed5e129.html">deduce_result_type&lt; T_functor, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, void, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce the return type of a functor. <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T_4788a98c68901ad51b4daf97aed5e129.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T_5c3a161eb5dba3c597d379b0bd504e5f.html">deduce_result_type&lt; T_functor, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce the return type of a functor. <a href="structsigc_1_1deduce__result__type_3_01T__functor_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T_5c3a161eb5dba3c597d379b0bd504e5f.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1adaptor__functor.html">adaptor_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an arbitrary functor into an adaptor type. <a href="structsigc_1_1adaptor__functor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1adapts.html">adapts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for adaptors. <a href="structsigc_1_1adapts.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3_010_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">bind_functor&lt; 0, T_functor, T_bound, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds an argument to the wrapped functor. <a href="structsigc_1_1bind__functor_3_010_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3_011_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">bind_functor&lt; 1, T_functor, T_bound, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds an argument to the wrapped functor. <a href="structsigc_1_1bind__functor_3_011_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3_012_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">bind_functor&lt; 2, T_functor, T_bound, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds an argument to the wrapped functor. <a href="structsigc_1_1bind__functor_3_012_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3_013_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">bind_functor&lt; 3, T_functor, T_bound, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds an argument to the wrapped functor. <a href="structsigc_1_1bind__functor_3_013_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3_014_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">bind_functor&lt; 4, T_functor, T_bound, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds an argument to the wrapped functor. <a href="structsigc_1_1bind__functor_3_014_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3_015_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">bind_functor&lt; 5, T_functor, T_bound, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds an argument to the wrapped functor. <a href="structsigc_1_1bind__functor_3_015_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3_016_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">bind_functor&lt; 6, T_functor, T_bound, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds an argument to the wrapped functor. <a href="structsigc_1_1bind__functor_3_016_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">bind_functor&lt;-1, T_functor, T_type1, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds 1 argument(s) to the wrapped functor. <a href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds 2 argument(s) to the wrapped functor. <a href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01n6d14effad731c8dfead9984e87967108.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, nil, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds 3 argument(s) to the wrapped functor. <a href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01n6d14effad731c8dfead9984e87967108.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T8abd615cc403946700f41917bb90042c.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds 4 argument(s) to the wrapped functor. <a href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T8abd615cc403946700f41917bb90042c.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01Tf230465d8da8d21a2da815d7eb05b413.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds 5 argument(s) to the wrapped functor. <a href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01Tf230465d8da8d21a2da815d7eb05b413.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T5d526f12c92849dac4a70f282eec9dc2.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds 6 argument(s) to the wrapped functor. <a href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T5d526f12c92849dac4a70f282eec9dc2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T1564029be5092b4f54029884f8072971.html">bind_functor&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, T_type7 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds 7 argument(s) to the wrapped functor. <a href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01T__type2_00_01T__type3_00_01T1564029be5092b4f54029884f8072971.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__return__functor.html">bind_return_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that fixes the return value of the wrapped functor. <a href="structsigc_1_1bind__return__functor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1retype__return__functor.html">retype_return_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that performs a C-style cast on the return value of a functor. <a href="structsigc_1_1retype__return__functor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1retype__return__functor_3_01void_00_01T__functor_01_4.html">retype_return_functor&lt; void, T_functor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that performs a C-style cast on the return value of a functor. <a href="structsigc_1_1retype__return__functor_3_01void_00_01T__functor_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1hide__functor_3-1_00_01T__functor_01_4.html">hide_functor&lt;-1, T_functor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor. <a href="structsigc_1_1hide__functor_3-1_00_01T__functor_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1hide__functor_3_010_00_01T__functor_01_4.html">hide_functor&lt; 0, T_functor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor. <a href="structsigc_1_1hide__functor_3_010_00_01T__functor_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1hide__functor_3_011_00_01T__functor_01_4.html">hide_functor&lt; 1, T_functor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor. <a href="structsigc_1_1hide__functor_3_011_00_01T__functor_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1hide__functor_3_012_00_01T__functor_01_4.html">hide_functor&lt; 2, T_functor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor. <a href="structsigc_1_1hide__functor_3_012_00_01T__functor_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1hide__functor_3_013_00_01T__functor_01_4.html">hide_functor&lt; 3, T_functor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor. <a href="structsigc_1_1hide__functor_3_013_00_01T__functor_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1hide__functor_3_014_00_01T__functor_01_4.html">hide_functor&lt; 4, T_functor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor. <a href="structsigc_1_1hide__functor_3_014_00_01T__functor_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1hide__functor_3_015_00_01T__functor_01_4.html">hide_functor&lt; 5, T_functor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor. <a href="structsigc_1_1hide__functor_3_015_00_01T__functor_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1hide__functor_3_016_00_01T__functor_01_4.html">hide_functor&lt; 6, T_functor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor. <a href="structsigc_1_1hide__functor_3_016_00_01T__functor_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that performs C-style casts on the parameters passed on to the functor. <a href="structsigc_1_1retype__functor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1compose1__functor.html">compose1_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that combines two functors. <a href="structsigc_1_1compose1__functor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1compose2__functor.html">compose2_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that combines three functors. <a href="structsigc_1_1compose2__functor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__base.html">lambda_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hint to the compiler. <a href="structsigc_1_1lambda__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda.html">lambda</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lambda type. <a href="structsigc_1_1lambda.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1unwrap__lambda__type.html">unwrap_lambda_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces the type of the object stored in an object of the passed lambda type. <a href="structsigc_1_1unwrap__lambda__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1dereference__trait.html">dereference_trait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces the base type of a reference or a pointer. <a href="structsigc_1_1dereference__trait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a48e982c74c057b5630246ba436524041"><td class="memTemplParams" colspan="2">template&lt;class T_type &gt; </td></tr>
<tr class="memitem:a48e982c74c057b5630246ba436524041"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1reference__wrapper.html">reference_wrapper</a>&lt; T_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a48e982c74c057b5630246ba436524041">ref</a> (T_type&amp; v)</td></tr>
<tr class="memdesc:a48e982c74c057b5630246ba436524041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a reference wrapper. <a href="#a48e982c74c057b5630246ba436524041"></a><br/></td></tr>
<tr class="separator:a48e982c74c057b5630246ba436524041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670882bd3fa5890b464871ac515aaba9"><td class="memTemplParams" colspan="2">template&lt;class T_type &gt; </td></tr>
<tr class="memitem:a670882bd3fa5890b464871ac515aaba9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1const__reference__wrapper.html">const_reference_wrapper</a>&lt; T_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a670882bd3fa5890b464871ac515aaba9">ref</a> (const T_type&amp; v)</td></tr>
<tr class="memdesc:a670882bd3fa5890b464871ac515aaba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a const reference wrapper. <a href="#a670882bd3fa5890b464871ac515aaba9"></a><br/></td></tr>
<tr class="separator:a670882bd3fa5890b464871ac515aaba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5529822bdaf60f07456633e0f40282"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3b5529822bdaf60f07456633e0f40282"></a>
template &lt;class T_type &gt; </td></tr>
<tr class="memitem:a3b5529822bdaf60f07456633e0f40282"><td class="memTemplItemLeft" align="right" valign="top">T_type&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unwrap</b> (const <a class="el" href="structsigc_1_1reference__wrapper.html">reference_wrapper</a>&lt; T_type &gt;&amp; v)</td></tr>
<tr class="separator:a3b5529822bdaf60f07456633e0f40282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f758c77e8743093f938d0c5dbf06778"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2f758c77e8743093f938d0c5dbf06778"></a>
template &lt;class T_type &gt; </td></tr>
<tr class="memitem:a2f758c77e8743093f938d0c5dbf06778"><td class="memTemplItemLeft" align="right" valign="top">const T_type&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unwrap</b> (const <a class="el" href="structsigc_1_1const__reference__wrapper.html">const_reference_wrapper</a>&lt; T_type &gt;&amp; v)</td></tr>
<tr class="separator:a2f758c77e8743093f938d0c5dbf06778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64cb7832acc1e58efb5ffe0b4f5e9404"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_functor &gt; </td></tr>
<tr class="memitem:ga64cb7832acc1e58efb5ffe0b4f5e9404"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404">visit_each</a> (const T_action&amp; _A_action, const T_functor&amp; _A_functor)</td></tr>
<tr class="memdesc:ga64cb7832acc1e58efb5ffe0b4f5e9404"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs a functor on each of the targets of a functor. <a href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404"></a><br/></td></tr>
<tr class="separator:ga64cb7832acc1e58efb5ffe0b4f5e9404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada222d975b87d64cfa7a7f29244ae587"><td class="memTemplParams" colspan="2"><a class="anchor" id="gada222d975b87d64cfa7a7f29244ae587"></a>
template &lt;class T_type , class T_action , class T_functor &gt; </td></tr>
<tr class="memitem:gada222d975b87d64cfa7a7f29244ae587"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sigcfunctors.html#gada222d975b87d64cfa7a7f29244ae587">visit_each_type</a> (const T_action&amp; _A_action, const T_functor&amp; _A_functor)</td></tr>
<tr class="memdesc:gada222d975b87d64cfa7a7f29244ae587"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs a functor on each of the targets of a functor limited to a restricted type. <br/></td></tr>
<tr class="separator:gada222d975b87d64cfa7a7f29244ae587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c399fa8208f9afd4793891f3656fb86"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_type &gt; </td></tr>
<tr class="memitem:a5c399fa8208f9afd4793891f3656fb86"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a5c399fa8208f9afd4793891f3656fb86">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__argument.html">bound_argument</a>&lt; T_type &gt;&amp; _A_argument)</td></tr>
<tr class="memdesc:a5c399fa8208f9afd4793891f3656fb86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> specialized for the <a class="el" href="classsigc_1_1bound__argument.html" title="A bound_argument&lt;Foo&gt; object stores a bound (for instance, with sigc::bind(), or sigc::bind_return())...">bound_argument</a> class. <a href="#a5c399fa8208f9afd4793891f3656fb86"></a><br/></td></tr>
<tr class="separator:a5c399fa8208f9afd4793891f3656fb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950519b7b414c384d808a4db9eefbd50"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_type , bool I_derives_trackable&gt; </td></tr>
<tr class="memitem:a950519b7b414c384d808a4db9eefbd50"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a950519b7b414c384d808a4db9eefbd50">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1limit__reference.html">limit_reference</a>&lt; T_type, I_derives_trackable &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:a950519b7b414c384d808a4db9eefbd50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> specialized for the <a class="el" href="classsigc_1_1limit__reference.html" title="A limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from sig...">limit_reference</a> class, to call <a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> on the entity returned by the <a class="el" href="classsigc_1_1limit__reference.html" title="A limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from sig...">limit_reference</a>'s visit() method. <a href="#a950519b7b414c384d808a4db9eefbd50"></a><br/></td></tr>
<tr class="separator:a950519b7b414c384d808a4db9eefbd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1deae338d4ae5fb2e9a49e6bffb31760"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_type , bool I_derives_trackable&gt; </td></tr>
<tr class="memitem:a1deae338d4ae5fb2e9a49e6bffb31760"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a1deae338d4ae5fb2e9a49e6bffb31760">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1const__limit__reference.html">const_limit_reference</a>&lt; T_type, I_derives_trackable &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:a1deae338d4ae5fb2e9a49e6bffb31760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> specialized for the <a class="el" href="classsigc_1_1const__limit__reference.html" title="A const_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from sigc::trackable, then visit_each&lt;&gt;() will &quot;limit&quot; itself to the sigc::trackable reference instead of the derived reference.">const_limit_reference</a> class, to call <a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> on the entity returned by the <a class="el" href="classsigc_1_1const__limit__reference.html" title="A const_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from sigc::trackable, then visit_each&lt;&gt;() will &quot;limit&quot; itself to the sigc::trackable reference instead of the derived reference.">const_limit_reference</a>'s visit() method. <a href="#a1deae338d4ae5fb2e9a49e6bffb31760"></a><br/></td></tr>
<tr class="separator:a1deae338d4ae5fb2e9a49e6bffb31760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2755fccba2c42f1613ed81c6477f8f8c"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_type , bool I_derives_trackable&gt; </td></tr>
<tr class="memitem:a2755fccba2c42f1613ed81c6477f8f8c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a2755fccba2c42f1613ed81c6477f8f8c">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1volatile__limit__reference.html">volatile_limit_reference</a>&lt; T_type, I_derives_trackable &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:a2755fccba2c42f1613ed81c6477f8f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> specialized for the <a class="el" href="classsigc_1_1volatile__limit__reference.html" title="A volatile_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from sigc::trackable, then visit_each&lt;&gt;() will &quot;limit&quot; itself to the sigc::trackable reference instead of the derived reference.">volatile_limit_reference</a> class, to call <a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> on the entity returned by the <a class="el" href="classsigc_1_1volatile__limit__reference.html" title="A volatile_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from sigc::trackable, then visit_each&lt;&gt;() will &quot;limit&quot; itself to the sigc::trackable reference instead of the derived reference.">volatile_limit_reference</a>'s visit() method. <a href="#a2755fccba2c42f1613ed81c6477f8f8c"></a><br/></td></tr>
<tr class="separator:a2755fccba2c42f1613ed81c6477f8f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335eb8de8833544f16cf12875f88d934"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_type , bool I_derives_trackable&gt; </td></tr>
<tr class="memitem:a335eb8de8833544f16cf12875f88d934"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a335eb8de8833544f16cf12875f88d934">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1const__volatile__limit__reference.html">const_volatile_limit_reference</a>&lt; T_type, I_derives_trackable &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:a335eb8de8833544f16cf12875f88d934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> specialized for the <a class="el" href="classsigc_1_1const__volatile__limit__reference.html" title="A const_volatile_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that...">const_volatile_limit_reference</a> class, to call <a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> on the entity returned by the <a class="el" href="classsigc_1_1const__volatile__limit__reference.html" title="A const_volatile_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that...">const_volatile_limit_reference</a>'s visit() method. <a href="#a335eb8de8833544f16cf12875f88d934"></a><br/></td></tr>
<tr class="separator:a335eb8de8833544f16cf12875f88d934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad8dffc194a4e4dfa0935ce49d43cd5c"><td class="memTemplParams" colspan="2">template&lt;class T_return &gt; </td></tr>
<tr class="memitem:gaad8dffc194a4e4dfa0935ce49d43cd5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor0.html">pointer_functor0</a>&lt; T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#gaad8dffc194a4e4dfa0935ce49d43cd5c">ptr_fun0</a> (T_return(* _A_func)())</td></tr>
<tr class="memdesc:gaad8dffc194a4e4dfa0935ce49d43cd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor0.html" title="pointer_functor0 wraps existing non-member functions with 0 argument(s).">sigc::pointer_functor0</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#gaad8dffc194a4e4dfa0935ce49d43cd5c"></a><br/></td></tr>
<tr class="separator:gaad8dffc194a4e4dfa0935ce49d43cd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b1b8e8f5555d6be4ba41be3fb82c94e"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return &gt; </td></tr>
<tr class="memitem:ga9b1b8e8f5555d6be4ba41be3fb82c94e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor1.html">pointer_functor1</a>&lt; T_arg1, <br class="typebreak"/>
T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga9b1b8e8f5555d6be4ba41be3fb82c94e">ptr_fun1</a> (T_return(* _A_func)(T_arg1))</td></tr>
<tr class="memdesc:ga9b1b8e8f5555d6be4ba41be3fb82c94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor1.html" title="pointer_functor1 wraps existing non-member functions with 1 argument(s).">sigc::pointer_functor1</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#ga9b1b8e8f5555d6be4ba41be3fb82c94e"></a><br/></td></tr>
<tr class="separator:ga9b1b8e8f5555d6be4ba41be3fb82c94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0244165b83e41a30b2dfb9523afad446"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return &gt; </td></tr>
<tr class="memitem:ga0244165b83e41a30b2dfb9523afad446"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor2.html">pointer_functor2</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga0244165b83e41a30b2dfb9523afad446">ptr_fun2</a> (T_return(* _A_func)(T_arg1, T_arg2))</td></tr>
<tr class="memdesc:ga0244165b83e41a30b2dfb9523afad446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor2.html" title="pointer_functor2 wraps existing non-member functions with 2 argument(s).">sigc::pointer_functor2</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#ga0244165b83e41a30b2dfb9523afad446"></a><br/></td></tr>
<tr class="separator:ga0244165b83e41a30b2dfb9523afad446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga749e83ea85926d5ad6994d775f98de8d"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return &gt; </td></tr>
<tr class="memitem:ga749e83ea85926d5ad6994d775f98de8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor3.html">pointer_functor3</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga749e83ea85926d5ad6994d775f98de8d">ptr_fun3</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr class="memdesc:ga749e83ea85926d5ad6994d775f98de8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor3.html" title="pointer_functor3 wraps existing non-member functions with 3 argument(s).">sigc::pointer_functor3</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#ga749e83ea85926d5ad6994d775f98de8d"></a><br/></td></tr>
<tr class="separator:ga749e83ea85926d5ad6994d775f98de8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6fa01189c786e778d943a2ee60896a4"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return &gt; </td></tr>
<tr class="memitem:gac6fa01189c786e778d943a2ee60896a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor4.html">pointer_functor4</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#gac6fa01189c786e778d943a2ee60896a4">ptr_fun4</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr class="memdesc:gac6fa01189c786e778d943a2ee60896a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor4.html" title="pointer_functor4 wraps existing non-member functions with 4 argument(s).">sigc::pointer_functor4</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#gac6fa01189c786e778d943a2ee60896a4"></a><br/></td></tr>
<tr class="separator:gac6fa01189c786e778d943a2ee60896a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37ae059caefef68e441d3dd7d5b11cce"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return &gt; </td></tr>
<tr class="memitem:ga37ae059caefef68e441d3dd7d5b11cce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor5.html">pointer_functor5</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga37ae059caefef68e441d3dd7d5b11cce">ptr_fun5</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr class="memdesc:ga37ae059caefef68e441d3dd7d5b11cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor5.html" title="pointer_functor5 wraps existing non-member functions with 5 argument(s).">sigc::pointer_functor5</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#ga37ae059caefef68e441d3dd7d5b11cce"></a><br/></td></tr>
<tr class="separator:ga37ae059caefef68e441d3dd7d5b11cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cdf17b7ec15b260f5147e1171dd5299"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return &gt; </td></tr>
<tr class="memitem:ga8cdf17b7ec15b260f5147e1171dd5299"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor6.html">pointer_functor6</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga8cdf17b7ec15b260f5147e1171dd5299">ptr_fun6</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr class="memdesc:ga8cdf17b7ec15b260f5147e1171dd5299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor6.html" title="pointer_functor6 wraps existing non-member functions with 6 argument(s).">sigc::pointer_functor6</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#ga8cdf17b7ec15b260f5147e1171dd5299"></a><br/></td></tr>
<tr class="separator:ga8cdf17b7ec15b260f5147e1171dd5299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82e53ab558dae814c16a09edb53617bb"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return &gt; </td></tr>
<tr class="memitem:ga82e53ab558dae814c16a09edb53617bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor7.html">pointer_functor7</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7, T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga82e53ab558dae814c16a09edb53617bb">ptr_fun7</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr class="memdesc:ga82e53ab558dae814c16a09edb53617bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor7.html" title="pointer_functor7 wraps existing non-member functions with 7 argument(s).">sigc::pointer_functor7</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#ga82e53ab558dae814c16a09edb53617bb"></a><br/></td></tr>
<tr class="separator:ga82e53ab558dae814c16a09edb53617bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c80de72f656fb05e81fda622dddc863"><td class="memTemplParams" colspan="2">template&lt;class T_return &gt; </td></tr>
<tr class="memitem:ga9c80de72f656fb05e81fda622dddc863"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor0.html">pointer_functor0</a>&lt; T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga9c80de72f656fb05e81fda622dddc863">ptr_fun</a> (T_return(* _A_func)())</td></tr>
<tr class="memdesc:ga9c80de72f656fb05e81fda622dddc863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor0.html" title="pointer_functor0 wraps existing non-member functions with 0 argument(s).">sigc::pointer_functor0</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#ga9c80de72f656fb05e81fda622dddc863"></a><br/></td></tr>
<tr class="separator:ga9c80de72f656fb05e81fda622dddc863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b1c3b4ecb24056f5bd38fc6a87f9ad1"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return &gt; </td></tr>
<tr class="memitem:ga9b1c3b4ecb24056f5bd38fc6a87f9ad1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor1.html">pointer_functor1</a>&lt; T_arg1, <br class="typebreak"/>
T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga9b1c3b4ecb24056f5bd38fc6a87f9ad1">ptr_fun</a> (T_return(* _A_func)(T_arg1))</td></tr>
<tr class="memdesc:ga9b1c3b4ecb24056f5bd38fc6a87f9ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor1.html" title="pointer_functor1 wraps existing non-member functions with 1 argument(s).">sigc::pointer_functor1</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#ga9b1c3b4ecb24056f5bd38fc6a87f9ad1"></a><br/></td></tr>
<tr class="separator:ga9b1c3b4ecb24056f5bd38fc6a87f9ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c0db14ab1a864b2bad70000325d94c8"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return &gt; </td></tr>
<tr class="memitem:ga9c0db14ab1a864b2bad70000325d94c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor2.html">pointer_functor2</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga9c0db14ab1a864b2bad70000325d94c8">ptr_fun</a> (T_return(* _A_func)(T_arg1, T_arg2))</td></tr>
<tr class="memdesc:ga9c0db14ab1a864b2bad70000325d94c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor2.html" title="pointer_functor2 wraps existing non-member functions with 2 argument(s).">sigc::pointer_functor2</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#ga9c0db14ab1a864b2bad70000325d94c8"></a><br/></td></tr>
<tr class="separator:ga9c0db14ab1a864b2bad70000325d94c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cd2254135f3afcfc5ce34e73cf2f48b"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return &gt; </td></tr>
<tr class="memitem:ga1cd2254135f3afcfc5ce34e73cf2f48b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor3.html">pointer_functor3</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga1cd2254135f3afcfc5ce34e73cf2f48b">ptr_fun</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr class="memdesc:ga1cd2254135f3afcfc5ce34e73cf2f48b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor3.html" title="pointer_functor3 wraps existing non-member functions with 3 argument(s).">sigc::pointer_functor3</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#ga1cd2254135f3afcfc5ce34e73cf2f48b"></a><br/></td></tr>
<tr class="separator:ga1cd2254135f3afcfc5ce34e73cf2f48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa23ae1abf223560bcac001b86d3cc484"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return &gt; </td></tr>
<tr class="memitem:gaa23ae1abf223560bcac001b86d3cc484"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor4.html">pointer_functor4</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#gaa23ae1abf223560bcac001b86d3cc484">ptr_fun</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr class="memdesc:gaa23ae1abf223560bcac001b86d3cc484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor4.html" title="pointer_functor4 wraps existing non-member functions with 4 argument(s).">sigc::pointer_functor4</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#gaa23ae1abf223560bcac001b86d3cc484"></a><br/></td></tr>
<tr class="separator:gaa23ae1abf223560bcac001b86d3cc484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd3087df10b981325953c93e914d451e"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return &gt; </td></tr>
<tr class="memitem:gafd3087df10b981325953c93e914d451e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor5.html">pointer_functor5</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#gafd3087df10b981325953c93e914d451e">ptr_fun</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr class="memdesc:gafd3087df10b981325953c93e914d451e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor5.html" title="pointer_functor5 wraps existing non-member functions with 5 argument(s).">sigc::pointer_functor5</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#gafd3087df10b981325953c93e914d451e"></a><br/></td></tr>
<tr class="separator:gafd3087df10b981325953c93e914d451e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f4d43c3aace56cc5ce0f38886b9ace6"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return &gt; </td></tr>
<tr class="memitem:ga0f4d43c3aace56cc5ce0f38886b9ace6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor6.html">pointer_functor6</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga0f4d43c3aace56cc5ce0f38886b9ace6">ptr_fun</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr class="memdesc:ga0f4d43c3aace56cc5ce0f38886b9ace6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor6.html" title="pointer_functor6 wraps existing non-member functions with 6 argument(s).">sigc::pointer_functor6</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#ga0f4d43c3aace56cc5ce0f38886b9ace6"></a><br/></td></tr>
<tr class="separator:ga0f4d43c3aace56cc5ce0f38886b9ace6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65221432dda1b020b73349627762da70"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return &gt; </td></tr>
<tr class="memitem:ga65221432dda1b020b73349627762da70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor7.html">pointer_functor7</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7, T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga65221432dda1b020b73349627762da70">ptr_fun</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr class="memdesc:ga65221432dda1b020b73349627762da70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor7.html" title="pointer_functor7 wraps existing non-member functions with 7 argument(s).">sigc::pointer_functor7</a> which wraps an existing non-member function. <a href="group__ptr__fun.html#ga65221432dda1b020b73349627762da70"></a><br/></td></tr>
<tr class="separator:ga65221432dda1b020b73349627762da70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd5e9a64995f5ca0f7895278a9ece6d6"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gabd5e9a64995f5ca0f7895278a9ece6d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gabd5e9a64995f5ca0f7895278a9ece6d6">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gabd5e9a64995f5ca0f7895278a9ece6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#gabd5e9a64995f5ca0f7895278a9ece6d6"></a><br/></td></tr>
<tr class="separator:gabd5e9a64995f5ca0f7895278a9ece6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a18696f671f364cfffb30f0e9611428"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr class="memitem:ga1a18696f671f364cfffb30f0e9611428"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga1a18696f671f364cfffb30f0e9611428">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga1a18696f671f364cfffb30f0e9611428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga1a18696f671f364cfffb30f0e9611428"></a><br/></td></tr>
<tr class="separator:ga1a18696f671f364cfffb30f0e9611428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63da7ee0d100b9e60613617cbd199a8d"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:ga63da7ee0d100b9e60613617cbd199a8d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga63da7ee0d100b9e60613617cbd199a8d">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga63da7ee0d100b9e60613617cbd199a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga63da7ee0d100b9e60613617cbd199a8d"></a><br/></td></tr>
<tr class="separator:ga63da7ee0d100b9e60613617cbd199a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf7482b0f9a6ea8426f5f1a108ed5539"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr class="memitem:gacf7482b0f9a6ea8426f5f1a108ed5539"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gacf7482b0f9a6ea8426f5f1a108ed5539">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gacf7482b0f9a6ea8426f5f1a108ed5539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#gacf7482b0f9a6ea8426f5f1a108ed5539"></a><br/></td></tr>
<tr class="separator:gacf7482b0f9a6ea8426f5f1a108ed5539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab85f8b77cba0d3928de62029c8f039e9"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr class="memitem:gab85f8b77cba0d3928de62029c8f039e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gab85f8b77cba0d3928de62029c8f039e9">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gab85f8b77cba0d3928de62029c8f039e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#gab85f8b77cba0d3928de62029c8f039e9"></a><br/></td></tr>
<tr class="separator:gab85f8b77cba0d3928de62029c8f039e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4d37bcfcf202f48a11e55cb6baadd6f"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr class="memitem:gab4d37bcfcf202f48a11e55cb6baadd6f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gab4d37bcfcf202f48a11e55cb6baadd6f">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gab4d37bcfcf202f48a11e55cb6baadd6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#gab4d37bcfcf202f48a11e55cb6baadd6f"></a><br/></td></tr>
<tr class="separator:gab4d37bcfcf202f48a11e55cb6baadd6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ef9a586816c1016e6c8f7b325301ab7"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr class="memitem:ga6ef9a586816c1016e6c8f7b325301ab7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga6ef9a586816c1016e6c8f7b325301ab7">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga6ef9a586816c1016e6c8f7b325301ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga6ef9a586816c1016e6c8f7b325301ab7"></a><br/></td></tr>
<tr class="separator:ga6ef9a586816c1016e6c8f7b325301ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga468e79dd7be56de4a3837b4c5fdde8ca"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr class="memitem:ga468e79dd7be56de4a3837b4c5fdde8ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga468e79dd7be56de4a3837b4c5fdde8ca">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga468e79dd7be56de4a3837b4c5fdde8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga468e79dd7be56de4a3837b4c5fdde8ca"></a><br/></td></tr>
<tr class="separator:ga468e79dd7be56de4a3837b4c5fdde8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c8e3d85a311ed8946447533b70d0d46"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga7c8e3d85a311ed8946447533b70d0d46"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga7c8e3d85a311ed8946447533b70d0d46">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga7c8e3d85a311ed8946447533b70d0d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga7c8e3d85a311ed8946447533b70d0d46"></a><br/></td></tr>
<tr class="separator:ga7c8e3d85a311ed8946447533b70d0d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee2a3da2684f1bcf2f53c7827c966867"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr class="memitem:gaee2a3da2684f1bcf2f53c7827c966867"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaee2a3da2684f1bcf2f53c7827c966867">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gaee2a3da2684f1bcf2f53c7827c966867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#gaee2a3da2684f1bcf2f53c7827c966867"></a><br/></td></tr>
<tr class="separator:gaee2a3da2684f1bcf2f53c7827c966867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec056e796fa861129436436d39aed604"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:gaec056e796fa861129436436d39aed604"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaec056e796fa861129436436d39aed604">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gaec056e796fa861129436436d39aed604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#gaec056e796fa861129436436d39aed604"></a><br/></td></tr>
<tr class="separator:gaec056e796fa861129436436d39aed604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79e40b784e00b7c442dcf7e5dba0e7d3"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr class="memitem:ga79e40b784e00b7c442dcf7e5dba0e7d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga79e40b784e00b7c442dcf7e5dba0e7d3">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga79e40b784e00b7c442dcf7e5dba0e7d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga79e40b784e00b7c442dcf7e5dba0e7d3"></a><br/></td></tr>
<tr class="separator:ga79e40b784e00b7c442dcf7e5dba0e7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf6f7626e673513f7a8850b4f3dd002f"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr class="memitem:gacf6f7626e673513f7a8850b4f3dd002f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gacf6f7626e673513f7a8850b4f3dd002f">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gacf6f7626e673513f7a8850b4f3dd002f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#gacf6f7626e673513f7a8850b4f3dd002f"></a><br/></td></tr>
<tr class="separator:gacf6f7626e673513f7a8850b4f3dd002f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga400f9f2d5b8f8ae4c3efd5291d8c278d"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr class="memitem:ga400f9f2d5b8f8ae4c3efd5291d8c278d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga400f9f2d5b8f8ae4c3efd5291d8c278d">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga400f9f2d5b8f8ae4c3efd5291d8c278d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga400f9f2d5b8f8ae4c3efd5291d8c278d"></a><br/></td></tr>
<tr class="separator:ga400f9f2d5b8f8ae4c3efd5291d8c278d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef07c518bd60eb9565c9091ec322476d"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr class="memitem:gaef07c518bd60eb9565c9091ec322476d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaef07c518bd60eb9565c9091ec322476d">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gaef07c518bd60eb9565c9091ec322476d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#gaef07c518bd60eb9565c9091ec322476d"></a><br/></td></tr>
<tr class="separator:gaef07c518bd60eb9565c9091ec322476d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga054db7e62e3f4cdc1a43c1c7023df7de"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr class="memitem:ga054db7e62e3f4cdc1a43c1c7023df7de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga054db7e62e3f4cdc1a43c1c7023df7de">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga054db7e62e3f4cdc1a43c1c7023df7de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga054db7e62e3f4cdc1a43c1c7023df7de"></a><br/></td></tr>
<tr class="separator:ga054db7e62e3f4cdc1a43c1c7023df7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9778e745dd100d983c7914229bd2560d"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga9778e745dd100d983c7914229bd2560d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga9778e745dd100d983c7914229bd2560d">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga9778e745dd100d983c7914229bd2560d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga9778e745dd100d983c7914229bd2560d"></a><br/></td></tr>
<tr class="separator:ga9778e745dd100d983c7914229bd2560d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3de3496749fd7647a85bcf376a4a832f"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr class="memitem:ga3de3496749fd7647a85bcf376a4a832f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga3de3496749fd7647a85bcf376a4a832f">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga3de3496749fd7647a85bcf376a4a832f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga3de3496749fd7647a85bcf376a4a832f"></a><br/></td></tr>
<tr class="separator:ga3de3496749fd7647a85bcf376a4a832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga469cf869c605b8ecf50fc31113dab706"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:ga469cf869c605b8ecf50fc31113dab706"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga469cf869c605b8ecf50fc31113dab706">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga469cf869c605b8ecf50fc31113dab706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga469cf869c605b8ecf50fc31113dab706"></a><br/></td></tr>
<tr class="separator:ga469cf869c605b8ecf50fc31113dab706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacab6d2c64c56e650d180005a3170bb19"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr class="memitem:gacab6d2c64c56e650d180005a3170bb19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gacab6d2c64c56e650d180005a3170bb19">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gacab6d2c64c56e650d180005a3170bb19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#gacab6d2c64c56e650d180005a3170bb19"></a><br/></td></tr>
<tr class="separator:gacab6d2c64c56e650d180005a3170bb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8b3078b7d2f36a4b82e09030e2cfa5a"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr class="memitem:gaf8b3078b7d2f36a4b82e09030e2cfa5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaf8b3078b7d2f36a4b82e09030e2cfa5a">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gaf8b3078b7d2f36a4b82e09030e2cfa5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#gaf8b3078b7d2f36a4b82e09030e2cfa5a"></a><br/></td></tr>
<tr class="separator:gaf8b3078b7d2f36a4b82e09030e2cfa5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb81af568daf632e59e2aeeb073956b5"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr class="memitem:gabb81af568daf632e59e2aeeb073956b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gabb81af568daf632e59e2aeeb073956b5">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gabb81af568daf632e59e2aeeb073956b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#gabb81af568daf632e59e2aeeb073956b5"></a><br/></td></tr>
<tr class="separator:gabb81af568daf632e59e2aeeb073956b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbb697f9fbf040c76368f2a1d778ea7d"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr class="memitem:gadbb697f9fbf040c76368f2a1d778ea7d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gadbb697f9fbf040c76368f2a1d778ea7d">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gadbb697f9fbf040c76368f2a1d778ea7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#gadbb697f9fbf040c76368f2a1d778ea7d"></a><br/></td></tr>
<tr class="separator:gadbb697f9fbf040c76368f2a1d778ea7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0514c3e40acd841d5e9c4ae4b774ded6"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr class="memitem:ga0514c3e40acd841d5e9c4ae4b774ded6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga0514c3e40acd841d5e9c4ae4b774ded6">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga0514c3e40acd841d5e9c4ae4b774ded6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga0514c3e40acd841d5e9c4ae4b774ded6"></a><br/></td></tr>
<tr class="separator:ga0514c3e40acd841d5e9c4ae4b774ded6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca854f6453dccd4a47f36721ddd3965e"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gaca854f6453dccd4a47f36721ddd3965e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaca854f6453dccd4a47f36721ddd3965e">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gaca854f6453dccd4a47f36721ddd3965e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#gaca854f6453dccd4a47f36721ddd3965e"></a><br/></td></tr>
<tr class="separator:gaca854f6453dccd4a47f36721ddd3965e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c0d65b88a0259e34437f0d0ea322251"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr class="memitem:ga4c0d65b88a0259e34437f0d0ea322251"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga4c0d65b88a0259e34437f0d0ea322251">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga4c0d65b88a0259e34437f0d0ea322251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga4c0d65b88a0259e34437f0d0ea322251"></a><br/></td></tr>
<tr class="separator:ga4c0d65b88a0259e34437f0d0ea322251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae260215430ab2b1ca8b80c40f5d0be00"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:gae260215430ab2b1ca8b80c40f5d0be00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gae260215430ab2b1ca8b80c40f5d0be00">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gae260215430ab2b1ca8b80c40f5d0be00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#gae260215430ab2b1ca8b80c40f5d0be00"></a><br/></td></tr>
<tr class="separator:gae260215430ab2b1ca8b80c40f5d0be00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3968c8eb9d73ea876c6b312d73e2c4a2"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr class="memitem:ga3968c8eb9d73ea876c6b312d73e2c4a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga3968c8eb9d73ea876c6b312d73e2c4a2">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga3968c8eb9d73ea876c6b312d73e2c4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga3968c8eb9d73ea876c6b312d73e2c4a2"></a><br/></td></tr>
<tr class="separator:ga3968c8eb9d73ea876c6b312d73e2c4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabed5fa33913a8234f792d31743004c42"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr class="memitem:gabed5fa33913a8234f792d31743004c42"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gabed5fa33913a8234f792d31743004c42">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gabed5fa33913a8234f792d31743004c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#gabed5fa33913a8234f792d31743004c42"></a><br/></td></tr>
<tr class="separator:gabed5fa33913a8234f792d31743004c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75a3dcba51260d7502ec923e8c0be5c6"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr class="memitem:ga75a3dcba51260d7502ec923e8c0be5c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga75a3dcba51260d7502ec923e8c0be5c6">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga75a3dcba51260d7502ec923e8c0be5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga75a3dcba51260d7502ec923e8c0be5c6"></a><br/></td></tr>
<tr class="separator:ga75a3dcba51260d7502ec923e8c0be5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3eee29bbfdb0fe95e0d31f32defb4b96"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr class="memitem:ga3eee29bbfdb0fe95e0d31f32defb4b96"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga3eee29bbfdb0fe95e0d31f32defb4b96">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga3eee29bbfdb0fe95e0d31f32defb4b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga3eee29bbfdb0fe95e0d31f32defb4b96"></a><br/></td></tr>
<tr class="separator:ga3eee29bbfdb0fe95e0d31f32defb4b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a0d4084f93bd2b1fcf95a5b495c4427"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr class="memitem:ga6a0d4084f93bd2b1fcf95a5b495c4427"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga6a0d4084f93bd2b1fcf95a5b495c4427">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga6a0d4084f93bd2b1fcf95a5b495c4427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__mem__fun.html#ga6a0d4084f93bd2b1fcf95a5b495c4427"></a><br/></td></tr>
<tr class="separator:ga6a0d4084f93bd2b1fcf95a5b495c4427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54eb73c592288db072ae8fdcd0271809"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga54eb73c592288db072ae8fdcd0271809"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a>&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga54eb73c592288db072ae8fdcd0271809">mem_fun0</a> (T_return(T_obj::* _A_func)())</td></tr>
<tr class="memdesc:ga54eb73c592288db072ae8fdcd0271809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor0.html" title="mem_functor0 wraps methods with 0 argument(s).">sigc::mem_functor0</a> which wraps a method. <a href="group__mem__fun.html#ga54eb73c592288db072ae8fdcd0271809"></a><br/></td></tr>
<tr class="separator:ga54eb73c592288db072ae8fdcd0271809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa89ed057c5d4a3fe7725f36840c2663"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gafa89ed057c5d4a3fe7725f36840c2663"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gafa89ed057c5d4a3fe7725f36840c2663">mem_fun1</a> (T_return(T_obj::* _A_func)(T_arg1))</td></tr>
<tr class="memdesc:gafa89ed057c5d4a3fe7725f36840c2663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor1.html" title="mem_functor1 wraps methods with 1 argument(s).">sigc::mem_functor1</a> which wraps a method. <a href="group__mem__fun.html#gafa89ed057c5d4a3fe7725f36840c2663"></a><br/></td></tr>
<tr class="separator:gafa89ed057c5d4a3fe7725f36840c2663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae58a6e612c3ddc06be3a23c261636442"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gae58a6e612c3ddc06be3a23c261636442"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gae58a6e612c3ddc06be3a23c261636442">mem_fun2</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr class="memdesc:gae58a6e612c3ddc06be3a23c261636442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor2.html" title="mem_functor2 wraps methods with 2 argument(s).">sigc::mem_functor2</a> which wraps a method. <a href="group__mem__fun.html#gae58a6e612c3ddc06be3a23c261636442"></a><br/></td></tr>
<tr class="separator:gae58a6e612c3ddc06be3a23c261636442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf8d584369e2c7d7b3cfea0ad6094a08"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gabf8d584369e2c7d7b3cfea0ad6094a08"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gabf8d584369e2c7d7b3cfea0ad6094a08">mem_fun3</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr class="memdesc:gabf8d584369e2c7d7b3cfea0ad6094a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor3.html" title="mem_functor3 wraps methods with 3 argument(s).">sigc::mem_functor3</a> which wraps a method. <a href="group__mem__fun.html#gabf8d584369e2c7d7b3cfea0ad6094a08"></a><br/></td></tr>
<tr class="separator:gabf8d584369e2c7d7b3cfea0ad6094a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef2aecfa6f95d7b5fdb3b9d2b43dad23"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gaef2aecfa6f95d7b5fdb3b9d2b43dad23"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaef2aecfa6f95d7b5fdb3b9d2b43dad23">mem_fun4</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr class="memdesc:gaef2aecfa6f95d7b5fdb3b9d2b43dad23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor4.html" title="mem_functor4 wraps methods with 4 argument(s).">sigc::mem_functor4</a> which wraps a method. <a href="group__mem__fun.html#gaef2aecfa6f95d7b5fdb3b9d2b43dad23"></a><br/></td></tr>
<tr class="separator:gaef2aecfa6f95d7b5fdb3b9d2b43dad23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b15cb11f5ecd0806f391f0e88a3c92a"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga8b15cb11f5ecd0806f391f0e88a3c92a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga8b15cb11f5ecd0806f391f0e88a3c92a">mem_fun5</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr class="memdesc:ga8b15cb11f5ecd0806f391f0e88a3c92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor5.html" title="mem_functor5 wraps methods with 5 argument(s).">sigc::mem_functor5</a> which wraps a method. <a href="group__mem__fun.html#ga8b15cb11f5ecd0806f391f0e88a3c92a"></a><br/></td></tr>
<tr class="separator:ga8b15cb11f5ecd0806f391f0e88a3c92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6705d585efb6c716ddb71c3eb0b0987c"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga6705d585efb6c716ddb71c3eb0b0987c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga6705d585efb6c716ddb71c3eb0b0987c">mem_fun6</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr class="memdesc:ga6705d585efb6c716ddb71c3eb0b0987c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor6.html" title="mem_functor6 wraps methods with 6 argument(s).">sigc::mem_functor6</a> which wraps a method. <a href="group__mem__fun.html#ga6705d585efb6c716ddb71c3eb0b0987c"></a><br/></td></tr>
<tr class="separator:ga6705d585efb6c716ddb71c3eb0b0987c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac74d8545aaf4999fe944157aef43ee30"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gac74d8545aaf4999fe944157aef43ee30"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gac74d8545aaf4999fe944157aef43ee30">mem_fun7</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr class="memdesc:gac74d8545aaf4999fe944157aef43ee30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor7.html" title="mem_functor7 wraps methods with 7 argument(s).">sigc::mem_functor7</a> which wraps a method. <a href="group__mem__fun.html#gac74d8545aaf4999fe944157aef43ee30"></a><br/></td></tr>
<tr class="separator:gac74d8545aaf4999fe944157aef43ee30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d417e21d7f2da74454e2b6cbd8e136d"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga7d417e21d7f2da74454e2b6cbd8e136d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a>&lt; T_return, <br class="typebreak"/>
T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga7d417e21d7f2da74454e2b6cbd8e136d">mem_fun0</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)())</td></tr>
<tr class="memdesc:ga7d417e21d7f2da74454e2b6cbd8e136d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance.">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga7d417e21d7f2da74454e2b6cbd8e136d"></a><br/></td></tr>
<tr class="separator:ga7d417e21d7f2da74454e2b6cbd8e136d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32580882b3288eb20b75a8c886a2e082"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga32580882b3288eb20b75a8c886a2e082"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a>&lt; T_return, <br class="typebreak"/>
T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga32580882b3288eb20b75a8c886a2e082">mem_fun0</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)())</td></tr>
<tr class="memdesc:ga32580882b3288eb20b75a8c886a2e082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance.">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga32580882b3288eb20b75a8c886a2e082"></a><br/></td></tr>
<tr class="separator:ga32580882b3288eb20b75a8c886a2e082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf1d0a1f044abdc784aa4fbcf9b827bf"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gadf1d0a1f044abdc784aa4fbcf9b827bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gadf1d0a1f044abdc784aa4fbcf9b827bf">mem_fun1</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>
<tr class="memdesc:gadf1d0a1f044abdc784aa4fbcf9b827bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance.">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#gadf1d0a1f044abdc784aa4fbcf9b827bf"></a><br/></td></tr>
<tr class="separator:gadf1d0a1f044abdc784aa4fbcf9b827bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab06ac23be30f9440af97b816e66cac06"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gab06ac23be30f9440af97b816e66cac06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gab06ac23be30f9440af97b816e66cac06">mem_fun1</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>
<tr class="memdesc:gab06ac23be30f9440af97b816e66cac06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance.">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#gab06ac23be30f9440af97b816e66cac06"></a><br/></td></tr>
<tr class="separator:gab06ac23be30f9440af97b816e66cac06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78bc4c78ef14d8b7adcb7cfcfc098516"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga78bc4c78ef14d8b7adcb7cfcfc098516"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga78bc4c78ef14d8b7adcb7cfcfc098516">mem_fun2</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr class="memdesc:ga78bc4c78ef14d8b7adcb7cfcfc098516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance.">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga78bc4c78ef14d8b7adcb7cfcfc098516"></a><br/></td></tr>
<tr class="separator:ga78bc4c78ef14d8b7adcb7cfcfc098516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae5eb7ef1e372250026726f7b7ed3855"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaae5eb7ef1e372250026726f7b7ed3855"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaae5eb7ef1e372250026726f7b7ed3855">mem_fun2</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr class="memdesc:gaae5eb7ef1e372250026726f7b7ed3855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance.">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#gaae5eb7ef1e372250026726f7b7ed3855"></a><br/></td></tr>
<tr class="separator:gaae5eb7ef1e372250026726f7b7ed3855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dd21580bac297f5c524a61de335ff1d"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga2dd21580bac297f5c524a61de335ff1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga2dd21580bac297f5c524a61de335ff1d">mem_fun3</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr class="memdesc:ga2dd21580bac297f5c524a61de335ff1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance.">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga2dd21580bac297f5c524a61de335ff1d"></a><br/></td></tr>
<tr class="separator:ga2dd21580bac297f5c524a61de335ff1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade548b8b0e42109cfa9c798e185649b6"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gade548b8b0e42109cfa9c798e185649b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gade548b8b0e42109cfa9c798e185649b6">mem_fun3</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr class="memdesc:gade548b8b0e42109cfa9c798e185649b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance.">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#gade548b8b0e42109cfa9c798e185649b6"></a><br/></td></tr>
<tr class="separator:gade548b8b0e42109cfa9c798e185649b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b4680747cc51964f04827b1febfe8fa"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga3b4680747cc51964f04827b1febfe8fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga3b4680747cc51964f04827b1febfe8fa">mem_fun4</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr class="memdesc:ga3b4680747cc51964f04827b1febfe8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance.">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga3b4680747cc51964f04827b1febfe8fa"></a><br/></td></tr>
<tr class="separator:ga3b4680747cc51964f04827b1febfe8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05a5dce6cbcfd3947857c3f2dd62699c"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga05a5dce6cbcfd3947857c3f2dd62699c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga05a5dce6cbcfd3947857c3f2dd62699c">mem_fun4</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr class="memdesc:ga05a5dce6cbcfd3947857c3f2dd62699c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance.">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga05a5dce6cbcfd3947857c3f2dd62699c"></a><br/></td></tr>
<tr class="separator:ga05a5dce6cbcfd3947857c3f2dd62699c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d2a08cc944e1dbb020eadbc0de96508"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga2d2a08cc944e1dbb020eadbc0de96508"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga2d2a08cc944e1dbb020eadbc0de96508">mem_fun5</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr class="memdesc:ga2d2a08cc944e1dbb020eadbc0de96508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance.">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga2d2a08cc944e1dbb020eadbc0de96508"></a><br/></td></tr>
<tr class="separator:ga2d2a08cc944e1dbb020eadbc0de96508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73450c8842822a9159ef22cfbdca1adb"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga73450c8842822a9159ef22cfbdca1adb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga73450c8842822a9159ef22cfbdca1adb">mem_fun5</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr class="memdesc:ga73450c8842822a9159ef22cfbdca1adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance.">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga73450c8842822a9159ef22cfbdca1adb"></a><br/></td></tr>
<tr class="separator:ga73450c8842822a9159ef22cfbdca1adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafba7801841d4c0c7d11f38f43d539831"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gafba7801841d4c0c7d11f38f43d539831"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gafba7801841d4c0c7d11f38f43d539831">mem_fun6</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr class="memdesc:gafba7801841d4c0c7d11f38f43d539831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance.">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#gafba7801841d4c0c7d11f38f43d539831"></a><br/></td></tr>
<tr class="separator:gafba7801841d4c0c7d11f38f43d539831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac928ab55a792369f529a8c270c17da3a"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gac928ab55a792369f529a8c270c17da3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gac928ab55a792369f529a8c270c17da3a">mem_fun6</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr class="memdesc:gac928ab55a792369f529a8c270c17da3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance.">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#gac928ab55a792369f529a8c270c17da3a"></a><br/></td></tr>
<tr class="separator:gac928ab55a792369f529a8c270c17da3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbbf9f8959def7c6bff925980e11097d"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gacbbf9f8959def7c6bff925980e11097d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gacbbf9f8959def7c6bff925980e11097d">mem_fun7</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr class="memdesc:gacbbf9f8959def7c6bff925980e11097d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance.">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#gacbbf9f8959def7c6bff925980e11097d"></a><br/></td></tr>
<tr class="separator:gacbbf9f8959def7c6bff925980e11097d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe7aa150fe88e0ddac5109aec246dedf"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gafe7aa150fe88e0ddac5109aec246dedf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gafe7aa150fe88e0ddac5109aec246dedf">mem_fun7</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr class="memdesc:gafe7aa150fe88e0ddac5109aec246dedf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance.">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#gafe7aa150fe88e0ddac5109aec246dedf"></a><br/></td></tr>
<tr class="separator:gafe7aa150fe88e0ddac5109aec246dedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52244864d2f65f072678b682bfc9913f"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga52244864d2f65f072678b682bfc9913f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a>&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga52244864d2f65f072678b682bfc9913f">mem_fun</a> (T_return(T_obj::* _A_func)())</td></tr>
<tr class="memdesc:ga52244864d2f65f072678b682bfc9913f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor0.html" title="mem_functor0 wraps methods with 0 argument(s).">sigc::mem_functor0</a> which wraps a method. <a href="group__mem__fun.html#ga52244864d2f65f072678b682bfc9913f"></a><br/></td></tr>
<tr class="separator:ga52244864d2f65f072678b682bfc9913f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafef5a8105ede7f183a1326c63b96ec85"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gafef5a8105ede7f183a1326c63b96ec85"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gafef5a8105ede7f183a1326c63b96ec85">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1))</td></tr>
<tr class="memdesc:gafef5a8105ede7f183a1326c63b96ec85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor1.html" title="mem_functor1 wraps methods with 1 argument(s).">sigc::mem_functor1</a> which wraps a method. <a href="group__mem__fun.html#gafef5a8105ede7f183a1326c63b96ec85"></a><br/></td></tr>
<tr class="separator:gafef5a8105ede7f183a1326c63b96ec85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5a9fe1ac29acc800bceecfd29c4c785"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gaf5a9fe1ac29acc800bceecfd29c4c785"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaf5a9fe1ac29acc800bceecfd29c4c785">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr class="memdesc:gaf5a9fe1ac29acc800bceecfd29c4c785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor2.html" title="mem_functor2 wraps methods with 2 argument(s).">sigc::mem_functor2</a> which wraps a method. <a href="group__mem__fun.html#gaf5a9fe1ac29acc800bceecfd29c4c785"></a><br/></td></tr>
<tr class="separator:gaf5a9fe1ac29acc800bceecfd29c4c785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd935ed360f79df6ac76d577a3628cfc"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gadd935ed360f79df6ac76d577a3628cfc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gadd935ed360f79df6ac76d577a3628cfc">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr class="memdesc:gadd935ed360f79df6ac76d577a3628cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor3.html" title="mem_functor3 wraps methods with 3 argument(s).">sigc::mem_functor3</a> which wraps a method. <a href="group__mem__fun.html#gadd935ed360f79df6ac76d577a3628cfc"></a><br/></td></tr>
<tr class="separator:gadd935ed360f79df6ac76d577a3628cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga658880c7fec0e2d7646ab9bee9a1b6d6"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga658880c7fec0e2d7646ab9bee9a1b6d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga658880c7fec0e2d7646ab9bee9a1b6d6">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr class="memdesc:ga658880c7fec0e2d7646ab9bee9a1b6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor4.html" title="mem_functor4 wraps methods with 4 argument(s).">sigc::mem_functor4</a> which wraps a method. <a href="group__mem__fun.html#ga658880c7fec0e2d7646ab9bee9a1b6d6"></a><br/></td></tr>
<tr class="separator:ga658880c7fec0e2d7646ab9bee9a1b6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d3509fb8e958e0bc0c5cd312b9140dd"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga3d3509fb8e958e0bc0c5cd312b9140dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga3d3509fb8e958e0bc0c5cd312b9140dd">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr class="memdesc:ga3d3509fb8e958e0bc0c5cd312b9140dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor5.html" title="mem_functor5 wraps methods with 5 argument(s).">sigc::mem_functor5</a> which wraps a method. <a href="group__mem__fun.html#ga3d3509fb8e958e0bc0c5cd312b9140dd"></a><br/></td></tr>
<tr class="separator:ga3d3509fb8e958e0bc0c5cd312b9140dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a670ee63fe536feb0bc6d70d3a17da0"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga4a670ee63fe536feb0bc6d70d3a17da0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga4a670ee63fe536feb0bc6d70d3a17da0">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr class="memdesc:ga4a670ee63fe536feb0bc6d70d3a17da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor6.html" title="mem_functor6 wraps methods with 6 argument(s).">sigc::mem_functor6</a> which wraps a method. <a href="group__mem__fun.html#ga4a670ee63fe536feb0bc6d70d3a17da0"></a><br/></td></tr>
<tr class="separator:ga4a670ee63fe536feb0bc6d70d3a17da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff7c688cda469057de1986106d2afbdf"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gaff7c688cda469057de1986106d2afbdf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaff7c688cda469057de1986106d2afbdf">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr class="memdesc:gaff7c688cda469057de1986106d2afbdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor7.html" title="mem_functor7 wraps methods with 7 argument(s).">sigc::mem_functor7</a> which wraps a method. <a href="group__mem__fun.html#gaff7c688cda469057de1986106d2afbdf"></a><br/></td></tr>
<tr class="separator:gaff7c688cda469057de1986106d2afbdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59dbc2d36afa5ee13876d0ee4c3efcba"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga59dbc2d36afa5ee13876d0ee4c3efcba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a>&lt; T_return, <br class="typebreak"/>
T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga59dbc2d36afa5ee13876d0ee4c3efcba">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)())</td></tr>
<tr class="memdesc:ga59dbc2d36afa5ee13876d0ee4c3efcba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance.">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga59dbc2d36afa5ee13876d0ee4c3efcba"></a><br/></td></tr>
<tr class="separator:ga59dbc2d36afa5ee13876d0ee4c3efcba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga880680f83a13cfa9cec0aac27d85cc4e"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga880680f83a13cfa9cec0aac27d85cc4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a>&lt; T_return, <br class="typebreak"/>
T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga880680f83a13cfa9cec0aac27d85cc4e">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)())</td></tr>
<tr class="memdesc:ga880680f83a13cfa9cec0aac27d85cc4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance.">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga880680f83a13cfa9cec0aac27d85cc4e"></a><br/></td></tr>
<tr class="separator:ga880680f83a13cfa9cec0aac27d85cc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e522ebdadfce0b7bf7919a002689206"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga4e522ebdadfce0b7bf7919a002689206"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga4e522ebdadfce0b7bf7919a002689206">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>
<tr class="memdesc:ga4e522ebdadfce0b7bf7919a002689206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance.">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga4e522ebdadfce0b7bf7919a002689206"></a><br/></td></tr>
<tr class="separator:ga4e522ebdadfce0b7bf7919a002689206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c4f25e76b5f05a52cb13610a6713e06"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga1c4f25e76b5f05a52cb13610a6713e06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga1c4f25e76b5f05a52cb13610a6713e06">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>
<tr class="memdesc:ga1c4f25e76b5f05a52cb13610a6713e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance.">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga1c4f25e76b5f05a52cb13610a6713e06"></a><br/></td></tr>
<tr class="separator:ga1c4f25e76b5f05a52cb13610a6713e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8a032173da28ce2f70e60b68c85b59f"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gac8a032173da28ce2f70e60b68c85b59f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gac8a032173da28ce2f70e60b68c85b59f">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr class="memdesc:gac8a032173da28ce2f70e60b68c85b59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance.">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#gac8a032173da28ce2f70e60b68c85b59f"></a><br/></td></tr>
<tr class="separator:gac8a032173da28ce2f70e60b68c85b59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d73a765ca6fbeceea48962319972eb2"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga1d73a765ca6fbeceea48962319972eb2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga1d73a765ca6fbeceea48962319972eb2">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr class="memdesc:ga1d73a765ca6fbeceea48962319972eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance.">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga1d73a765ca6fbeceea48962319972eb2"></a><br/></td></tr>
<tr class="separator:ga1d73a765ca6fbeceea48962319972eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf67c13f2600b3adee5d71c720e34f200"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaf67c13f2600b3adee5d71c720e34f200"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaf67c13f2600b3adee5d71c720e34f200">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr class="memdesc:gaf67c13f2600b3adee5d71c720e34f200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance.">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#gaf67c13f2600b3adee5d71c720e34f200"></a><br/></td></tr>
<tr class="separator:gaf67c13f2600b3adee5d71c720e34f200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb986cff130c08774b2b273a7130bfa4"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gafb986cff130c08774b2b273a7130bfa4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gafb986cff130c08774b2b273a7130bfa4">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr class="memdesc:gafb986cff130c08774b2b273a7130bfa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance.">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#gafb986cff130c08774b2b273a7130bfa4"></a><br/></td></tr>
<tr class="separator:gafb986cff130c08774b2b273a7130bfa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9289d4ffd3df262fa70c4997713f30f2"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga9289d4ffd3df262fa70c4997713f30f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga9289d4ffd3df262fa70c4997713f30f2">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr class="memdesc:ga9289d4ffd3df262fa70c4997713f30f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance.">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga9289d4ffd3df262fa70c4997713f30f2"></a><br/></td></tr>
<tr class="separator:ga9289d4ffd3df262fa70c4997713f30f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga104fe5c3642e3e090cfd3a28b71277fb"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga104fe5c3642e3e090cfd3a28b71277fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga104fe5c3642e3e090cfd3a28b71277fb">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr class="memdesc:ga104fe5c3642e3e090cfd3a28b71277fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance.">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga104fe5c3642e3e090cfd3a28b71277fb"></a><br/></td></tr>
<tr class="separator:ga104fe5c3642e3e090cfd3a28b71277fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf60bdc06ae0f6c3ef711b018987028dc"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaf60bdc06ae0f6c3ef711b018987028dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaf60bdc06ae0f6c3ef711b018987028dc">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr class="memdesc:gaf60bdc06ae0f6c3ef711b018987028dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance.">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#gaf60bdc06ae0f6c3ef711b018987028dc"></a><br/></td></tr>
<tr class="separator:gaf60bdc06ae0f6c3ef711b018987028dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3233d1890d3de2865c3ee31b8dad943"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gac3233d1890d3de2865c3ee31b8dad943"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gac3233d1890d3de2865c3ee31b8dad943">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr class="memdesc:gac3233d1890d3de2865c3ee31b8dad943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance.">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#gac3233d1890d3de2865c3ee31b8dad943"></a><br/></td></tr>
<tr class="separator:gac3233d1890d3de2865c3ee31b8dad943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2f919081dbdb355280fee7c03d38e2b"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gac2f919081dbdb355280fee7c03d38e2b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gac2f919081dbdb355280fee7c03d38e2b">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr class="memdesc:gac2f919081dbdb355280fee7c03d38e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance.">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#gac2f919081dbdb355280fee7c03d38e2b"></a><br/></td></tr>
<tr class="separator:gac2f919081dbdb355280fee7c03d38e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97a2b07475e715526bb233f193d22b0c"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga97a2b07475e715526bb233f193d22b0c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga97a2b07475e715526bb233f193d22b0c">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr class="memdesc:ga97a2b07475e715526bb233f193d22b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance.">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga97a2b07475e715526bb233f193d22b0c"></a><br/></td></tr>
<tr class="separator:ga97a2b07475e715526bb233f193d22b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga155503aac650f7d8a575de477d1b3334"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga155503aac650f7d8a575de477d1b3334"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga155503aac650f7d8a575de477d1b3334">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr class="memdesc:ga155503aac650f7d8a575de477d1b3334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance.">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga155503aac650f7d8a575de477d1b3334"></a><br/></td></tr>
<tr class="separator:ga155503aac650f7d8a575de477d1b3334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga560c76b57874fef9e3a1cc113276edad"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga560c76b57874fef9e3a1cc113276edad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga560c76b57874fef9e3a1cc113276edad">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr class="memdesc:ga560c76b57874fef9e3a1cc113276edad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance.">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance. <a href="group__mem__fun.html#ga560c76b57874fef9e3a1cc113276edad"></a><br/></td></tr>
<tr class="separator:ga560c76b57874fef9e3a1cc113276edad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga461535b73453031f058475c036eeef05"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_functor &gt; </td></tr>
<tr class="memitem:ga461535b73453031f058475c036eeef05"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__adaptors.html#ga461535b73453031f058475c036eeef05">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1adaptor__functor.html">adaptor_functor</a>&lt; T_functor &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga461535b73453031f058475c036eeef05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__adaptors.html#ga461535b73453031f058475c036eeef05"></a><br/></td></tr>
<tr class="separator:ga461535b73453031f058475c036eeef05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefc1fa87d6a79d83006c27151fbcef9f"><td class="memTemplParams" colspan="2">template&lt;class T_action , int T_loc, class T_functor , class T_bound &gt; </td></tr>
<tr class="memitem:gaefc1fa87d6a79d83006c27151fbcef9f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#gaefc1fa87d6a79d83006c27151fbcef9f">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structbind__functor.html">bind_functor</a>&lt; T_loc, T_functor, T_bound &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gaefc1fa87d6a79d83006c27151fbcef9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__bind.html#gaefc1fa87d6a79d83006c27151fbcef9f"></a><br/></td></tr>
<tr class="separator:gaefc1fa87d6a79d83006c27151fbcef9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga268c43109e3d55c7cebf105aef912705"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_functor , class T_type1 &gt; </td></tr>
<tr class="memitem:ga268c43109e3d55c7cebf105aef912705"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ga268c43109e3d55c7cebf105aef912705">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structbind__functor.html">bind_functor</a>&lt;-1, T_functor, T_type1 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga268c43109e3d55c7cebf105aef912705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__bind.html#ga268c43109e3d55c7cebf105aef912705"></a><br/></td></tr>
<tr class="separator:ga268c43109e3d55c7cebf105aef912705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ec867588f4122ca77238cb8d2021bec"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_functor , class T_type1 , class T_type2 &gt; </td></tr>
<tr class="memitem:ga4ec867588f4122ca77238cb8d2021bec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ga4ec867588f4122ca77238cb8d2021bec">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structbind__functor.html">bind_functor</a>&lt;-1, T_functor, T_type1, T_type2 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga4ec867588f4122ca77238cb8d2021bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__bind.html#ga4ec867588f4122ca77238cb8d2021bec"></a><br/></td></tr>
<tr class="separator:ga4ec867588f4122ca77238cb8d2021bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa84f3e871b74ec5b0388476428de472a"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_functor , class T_type1 , class T_type2 , class T_type3 &gt; </td></tr>
<tr class="memitem:gaa84f3e871b74ec5b0388476428de472a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#gaa84f3e871b74ec5b0388476428de472a">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structbind__functor.html">bind_functor</a>&lt;-1, T_functor, T_type1, T_type2, T_type3 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gaa84f3e871b74ec5b0388476428de472a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__bind.html#gaa84f3e871b74ec5b0388476428de472a"></a><br/></td></tr>
<tr class="separator:gaa84f3e871b74ec5b0388476428de472a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaace21506b1ef1e07ee9060b4a064d45e"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_functor , class T_type1 , class T_type2 , class T_type3 , class T_type4 &gt; </td></tr>
<tr class="memitem:gaace21506b1ef1e07ee9060b4a064d45e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#gaace21506b1ef1e07ee9060b4a064d45e">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structbind__functor.html">bind_functor</a>&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gaace21506b1ef1e07ee9060b4a064d45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__bind.html#gaace21506b1ef1e07ee9060b4a064d45e"></a><br/></td></tr>
<tr class="separator:gaace21506b1ef1e07ee9060b4a064d45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b486c731d5faff2c8e99a9443a9f249"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_functor , class T_type1 , class T_type2 , class T_type3 , class T_type4 , class T_type5 &gt; </td></tr>
<tr class="memitem:ga4b486c731d5faff2c8e99a9443a9f249"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ga4b486c731d5faff2c8e99a9443a9f249">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structbind__functor.html">bind_functor</a>&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga4b486c731d5faff2c8e99a9443a9f249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__bind.html#ga4b486c731d5faff2c8e99a9443a9f249"></a><br/></td></tr>
<tr class="separator:ga4b486c731d5faff2c8e99a9443a9f249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b2015b23fde5157362e44ae6803015f"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_functor , class T_type1 , class T_type2 , class T_type3 , class T_type4 , class T_type5 , class T_type6 &gt; </td></tr>
<tr class="memitem:ga4b2015b23fde5157362e44ae6803015f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ga4b2015b23fde5157362e44ae6803015f">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structbind__functor.html">bind_functor</a>&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga4b2015b23fde5157362e44ae6803015f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__bind.html#ga4b2015b23fde5157362e44ae6803015f"></a><br/></td></tr>
<tr class="separator:ga4b2015b23fde5157362e44ae6803015f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d324ecfa0eae9bedfa3590f0456b115"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_functor , class T_type1 , class T_type2 , class T_type3 , class T_type4 , class T_type5 , class T_type6 , class T_type7 &gt; </td></tr>
<tr class="memitem:ga4d324ecfa0eae9bedfa3590f0456b115"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ga4d324ecfa0eae9bedfa3590f0456b115">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structbind__functor.html">bind_functor</a>&lt;-1, T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, T_type7 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga4d324ecfa0eae9bedfa3590f0456b115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__bind.html#ga4d324ecfa0eae9bedfa3590f0456b115"></a><br/></td></tr>
<tr class="separator:ga4d324ecfa0eae9bedfa3590f0456b115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f099bc6056b32f2a58134ba8537c6f4"><td class="memTemplParams" colspan="2">template&lt;int I_location, class T_bound1 , class T_functor &gt; </td></tr>
<tr class="memitem:ga2f099bc6056b32f2a58134ba8537c6f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbind__functor.html">bind_functor</a>&lt; I_location, <br class="typebreak"/>
T_functor, T_bound1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ga2f099bc6056b32f2a58134ba8537c6f4">bind</a> (const T_functor&amp; _A_func, T_bound1 _A_b1)</td></tr>
<tr class="memdesc:ga2f099bc6056b32f2a58134ba8537c6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which binds the passed argument to the passed functor. <a href="group__bind.html#ga2f099bc6056b32f2a58134ba8537c6f4"></a><br/></td></tr>
<tr class="separator:ga2f099bc6056b32f2a58134ba8537c6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga211b3361bb1ae7484b2b276fd926b962"><td class="memTemplParams" colspan="2">template&lt;class T_type1 , class T_functor &gt; </td></tr>
<tr class="memitem:ga211b3361bb1ae7484b2b276fd926b962"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbind__functor.html">bind_functor</a>&lt;-1, T_functor, <br class="typebreak"/>
T_type1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ga211b3361bb1ae7484b2b276fd926b962">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1)</td></tr>
<tr class="memdesc:ga211b3361bb1ae7484b2b276fd926b962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which fixes the last 1 argument(s) of the passed functor. <a href="group__bind.html#ga211b3361bb1ae7484b2b276fd926b962"></a><br/></td></tr>
<tr class="separator:ga211b3361bb1ae7484b2b276fd926b962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1e076f0734addb8080f1cbcac602591"><td class="memTemplParams" colspan="2">template&lt;class T_type1 , class T_type2 , class T_functor &gt; </td></tr>
<tr class="memitem:gaf1e076f0734addb8080f1cbcac602591"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbind__functor.html">bind_functor</a>&lt;-1, T_functor, <br class="typebreak"/>
T_type1, T_type2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#gaf1e076f0734addb8080f1cbcac602591">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1, T_type2 _A_b2)</td></tr>
<tr class="memdesc:gaf1e076f0734addb8080f1cbcac602591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which fixes the last 2 argument(s) of the passed functor. <a href="group__bind.html#gaf1e076f0734addb8080f1cbcac602591"></a><br/></td></tr>
<tr class="separator:gaf1e076f0734addb8080f1cbcac602591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga047061c9fa7d9dcde68c27cceed476a1"><td class="memTemplParams" colspan="2">template&lt;class T_type1 , class T_type2 , class T_type3 , class T_functor &gt; </td></tr>
<tr class="memitem:ga047061c9fa7d9dcde68c27cceed476a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbind__functor.html">bind_functor</a>&lt;-1, T_functor, <br class="typebreak"/>
T_type1, T_type2, T_type3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ga047061c9fa7d9dcde68c27cceed476a1">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1, T_type2 _A_b2, T_type3 _A_b3)</td></tr>
<tr class="memdesc:ga047061c9fa7d9dcde68c27cceed476a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which fixes the last 3 argument(s) of the passed functor. <a href="group__bind.html#ga047061c9fa7d9dcde68c27cceed476a1"></a><br/></td></tr>
<tr class="separator:ga047061c9fa7d9dcde68c27cceed476a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8366abceb86ee653ec2ac50cef9fd16d"><td class="memTemplParams" colspan="2">template&lt;class T_type1 , class T_type2 , class T_type3 , class T_type4 , class T_functor &gt; </td></tr>
<tr class="memitem:ga8366abceb86ee653ec2ac50cef9fd16d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbind__functor.html">bind_functor</a>&lt;-1, T_functor, <br class="typebreak"/>
T_type1, T_type2, T_type3, <br class="typebreak"/>
T_type4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ga8366abceb86ee653ec2ac50cef9fd16d">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1, T_type2 _A_b2, T_type3 _A_b3, T_type4 _A_b4)</td></tr>
<tr class="memdesc:ga8366abceb86ee653ec2ac50cef9fd16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which fixes the last 4 argument(s) of the passed functor. <a href="group__bind.html#ga8366abceb86ee653ec2ac50cef9fd16d"></a><br/></td></tr>
<tr class="separator:ga8366abceb86ee653ec2ac50cef9fd16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f163c830d7906906cf21ff0c5e0f17f"><td class="memTemplParams" colspan="2">template&lt;class T_type1 , class T_type2 , class T_type3 , class T_type4 , class T_type5 , class T_functor &gt; </td></tr>
<tr class="memitem:ga7f163c830d7906906cf21ff0c5e0f17f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbind__functor.html">bind_functor</a>&lt;-1, T_functor, <br class="typebreak"/>
T_type1, T_type2, T_type3, <br class="typebreak"/>
T_type4, T_type5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ga7f163c830d7906906cf21ff0c5e0f17f">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1, T_type2 _A_b2, T_type3 _A_b3, T_type4 _A_b4, T_type5 _A_b5)</td></tr>
<tr class="memdesc:ga7f163c830d7906906cf21ff0c5e0f17f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which fixes the last 5 argument(s) of the passed functor. <a href="group__bind.html#ga7f163c830d7906906cf21ff0c5e0f17f"></a><br/></td></tr>
<tr class="separator:ga7f163c830d7906906cf21ff0c5e0f17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac370f58b773f68c229c181f07e9b9e79"><td class="memTemplParams" colspan="2">template&lt;class T_type1 , class T_type2 , class T_type3 , class T_type4 , class T_type5 , class T_type6 , class T_functor &gt; </td></tr>
<tr class="memitem:gac370f58b773f68c229c181f07e9b9e79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbind__functor.html">bind_functor</a>&lt;-1, T_functor, <br class="typebreak"/>
T_type1, T_type2, T_type3, <br class="typebreak"/>
T_type4, T_type5, T_type6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#gac370f58b773f68c229c181f07e9b9e79">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1, T_type2 _A_b2, T_type3 _A_b3, T_type4 _A_b4, T_type5 _A_b5, T_type6 _A_b6)</td></tr>
<tr class="memdesc:gac370f58b773f68c229c181f07e9b9e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which fixes the last 6 argument(s) of the passed functor. <a href="group__bind.html#gac370f58b773f68c229c181f07e9b9e79"></a><br/></td></tr>
<tr class="separator:gac370f58b773f68c229c181f07e9b9e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga962b581ef0c17562bb3317783d3ffe7d"><td class="memTemplParams" colspan="2">template&lt;class T_type1 , class T_type2 , class T_type3 , class T_type4 , class T_type5 , class T_type6 , class T_type7 , class T_functor &gt; </td></tr>
<tr class="memitem:ga962b581ef0c17562bb3317783d3ffe7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbind__functor.html">bind_functor</a>&lt;-1, T_functor, <br class="typebreak"/>
T_type1, T_type2, T_type3, <br class="typebreak"/>
T_type4, T_type5, T_type6, <br class="typebreak"/>
T_type7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ga962b581ef0c17562bb3317783d3ffe7d">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1, T_type2 _A_b2, T_type3 _A_b3, T_type4 _A_b4, T_type5 _A_b5, T_type6 _A_b6, T_type7 _A_b7)</td></tr>
<tr class="memdesc:ga962b581ef0c17562bb3317783d3ffe7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type sigc::bind_functor which fixes the last 7 argument(s) of the passed functor. <a href="group__bind.html#ga962b581ef0c17562bb3317783d3ffe7d"></a><br/></td></tr>
<tr class="separator:ga962b581ef0c17562bb3317783d3ffe7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97b6e639edb581f582c29d1c90fc735d"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_functor &gt; </td></tr>
<tr class="memitem:ga97b6e639edb581f582c29d1c90fc735d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ga97b6e639edb581f582c29d1c90fc735d">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1bind__return__functor.html">bind_return_functor</a>&lt; T_return, T_functor &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga97b6e639edb581f582c29d1c90fc735d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__bind.html#ga97b6e639edb581f582c29d1c90fc735d"></a><br/></td></tr>
<tr class="separator:ga97b6e639edb581f582c29d1c90fc735d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca1ae2466988d67d00a5f2cd16c8d90a"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_functor &gt; </td></tr>
<tr class="memitem:gaca1ae2466988d67d00a5f2cd16c8d90a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1bind__return__functor.html">bind_return_functor</a>&lt; T_return, <br class="typebreak"/>
T_functor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#gaca1ae2466988d67d00a5f2cd16c8d90a">bind_return</a> (const T_functor&amp; _A_functor, T_return _A_ret_value)</td></tr>
<tr class="memdesc:gaca1ae2466988d67d00a5f2cd16c8d90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1bind__return__functor.html" title="Adaptor that fixes the return value of the wrapped functor.">sigc::bind_return_functor</a> which fixes the return value of the passed functor to the passed argument. <a href="group__bind.html#gaca1ae2466988d67d00a5f2cd16c8d90a"></a><br/></td></tr>
<tr class="separator:gaca1ae2466988d67d00a5f2cd16c8d90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5191a365cf9836d05ad2084fd5154c8f"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_return , class T_functor &gt; </td></tr>
<tr class="memitem:ga5191a365cf9836d05ad2084fd5154c8f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga5191a365cf9836d05ad2084fd5154c8f">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1retype__return__functor.html">retype_return_functor</a>&lt; T_return, T_functor &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga5191a365cf9836d05ad2084fd5154c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__retype.html#ga5191a365cf9836d05ad2084fd5154c8f"></a><br/></td></tr>
<tr class="separator:ga5191a365cf9836d05ad2084fd5154c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23a8cdbc12c57fbef0866b5c51d71588"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_functor &gt; </td></tr>
<tr class="memitem:ga23a8cdbc12c57fbef0866b5c51d71588"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__return__functor.html">retype_return_functor</a><br class="typebreak"/>
&lt; T_return, T_functor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga23a8cdbc12c57fbef0866b5c51d71588">retype_return</a> (const T_functor&amp; _A_functor)</td></tr>
<tr class="memdesc:ga23a8cdbc12c57fbef0866b5c51d71588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__return__functor.html" title="Adaptor that performs a C-style cast on the return value of a functor.">sigc::retype_return_functor</a> which performs a C-style cast on the return value of the passed functor. <a href="group__retype.html#ga23a8cdbc12c57fbef0866b5c51d71588"></a><br/></td></tr>
<tr class="separator:ga23a8cdbc12c57fbef0866b5c51d71588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4e6f5491471c12440f1c5d480726b98"><td class="memTemplParams" colspan="2">template&lt;class T_functor &gt; </td></tr>
<tr class="memitem:gae4e6f5491471c12440f1c5d480726b98"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__return__functor.html">retype_return_functor</a>&lt; void, <br class="typebreak"/>
T_functor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hide.html#gae4e6f5491471c12440f1c5d480726b98">hide_return</a> (const T_functor&amp; _A_functor)</td></tr>
<tr class="memdesc:gae4e6f5491471c12440f1c5d480726b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__return__functor.html" title="Adaptor that performs a C-style cast on the return value of a functor.">sigc::retype_return_functor</a> which drops the return value of the passed functor. <a href="group__hide.html#gae4e6f5491471c12440f1c5d480726b98"></a><br/></td></tr>
<tr class="separator:gae4e6f5491471c12440f1c5d480726b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4404d1e75fbbc30719ef6ac4c8f43b11"><td class="memTemplParams" colspan="2">template&lt;class T_action , int I_location, class T_functor &gt; </td></tr>
<tr class="memitem:ga4404d1e75fbbc30719ef6ac4c8f43b11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hide.html#ga4404d1e75fbbc30719ef6ac4c8f43b11">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structhide__functor.html">hide_functor</a>&lt; I_location, T_functor &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga4404d1e75fbbc30719ef6ac4c8f43b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__hide.html#ga4404d1e75fbbc30719ef6ac4c8f43b11"></a><br/></td></tr>
<tr class="separator:ga4404d1e75fbbc30719ef6ac4c8f43b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2cefea3a99acd44f68121424103172d"><td class="memTemplParams" colspan="2">template&lt;int I_location, class T_functor &gt; </td></tr>
<tr class="memitem:gaf2cefea3a99acd44f68121424103172d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structhide__functor.html">hide_functor</a>&lt; I_location, <br class="typebreak"/>
T_functor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hide.html#gaf2cefea3a99acd44f68121424103172d">hide</a> (const T_functor&amp; _A_func)</td></tr>
<tr class="memdesc:gaf2cefea3a99acd44f68121424103172d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type sigc::hide_functor which adds a dummy parameter to the passed functor. <a href="group__hide.html#gaf2cefea3a99acd44f68121424103172d"></a><br/></td></tr>
<tr class="separator:gaf2cefea3a99acd44f68121424103172d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbbacd3553268d85b95e3a85aefb67e5"><td class="memTemplParams" colspan="2">template&lt;class T_functor &gt; </td></tr>
<tr class="memitem:gacbbacd3553268d85b95e3a85aefb67e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structhide__functor.html">hide_functor</a>&lt;-1, T_functor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hide.html#gacbbacd3553268d85b95e3a85aefb67e5">hide</a> (const T_functor&amp; _A_func)</td></tr>
<tr class="memdesc:gacbbacd3553268d85b95e3a85aefb67e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type sigc::hide_functor which adds a dummy parameter to the passed functor. <a href="group__hide.html#gacbbacd3553268d85b95e3a85aefb67e5"></a><br/></td></tr>
<tr class="separator:gacbbacd3553268d85b95e3a85aefb67e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fd4d8e79bec5dee1bb40c893b76afe0"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_functor , class T_type1 , class T_type2 , class T_type3 , class T_type4 , class T_type5 , class T_type6 , class T_type7 &gt; </td></tr>
<tr class="memitem:ga1fd4d8e79bec5dee1bb40c893b76afe0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga1fd4d8e79bec5dee1bb40c893b76afe0">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; T_functor, T_type1, T_type2, T_type3, T_type4, T_type5, T_type6, T_type7 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga1fd4d8e79bec5dee1bb40c893b76afe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__retype.html#ga1fd4d8e79bec5dee1bb40c893b76afe0"></a><br/></td></tr>
<tr class="separator:ga1fd4d8e79bec5dee1bb40c893b76afe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b98eeb2a61b5b1f84dcd1d20fe666f1"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr class="memitem:ga8b98eeb2a61b5b1f84dcd1d20fe666f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1slot.html">slot</a>&lt; T_return, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5, T_arg6, T_arg7 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga8b98eeb2a61b5b1f84dcd1d20fe666f1">retype</a> (const <a class="el" href="classsigc_1_1slot.html">slot</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga8b98eeb2a61b5b1f84dcd1d20fe666f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga8b98eeb2a61b5b1f84dcd1d20fe666f1"></a><br/></td></tr>
<tr class="separator:ga8b98eeb2a61b5b1f84dcd1d20fe666f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23978c94d9d3c934803898c3bf48ff7d"><td class="memTemplParams" colspan="2">template&lt;class T_return &gt; </td></tr>
<tr class="memitem:ga23978c94d9d3c934803898c3bf48ff7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1pointer__functor0.html">pointer_functor0</a>&lt; T_return &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga23978c94d9d3c934803898c3bf48ff7d">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor0.html">pointer_functor0</a>&lt; T_return &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga23978c94d9d3c934803898c3bf48ff7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga23978c94d9d3c934803898c3bf48ff7d"></a><br/></td></tr>
<tr class="separator:ga23978c94d9d3c934803898c3bf48ff7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75cc92c15faf06d5293ff34179f21899"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return &gt; </td></tr>
<tr class="memitem:ga75cc92c15faf06d5293ff34179f21899"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1pointer__functor1.html">pointer_functor1</a>&lt; T_arg1, <br class="typebreak"/>
T_return &gt;, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga75cc92c15faf06d5293ff34179f21899">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor1.html">pointer_functor1</a>&lt; T_arg1, T_return &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga75cc92c15faf06d5293ff34179f21899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga75cc92c15faf06d5293ff34179f21899"></a><br/></td></tr>
<tr class="separator:ga75cc92c15faf06d5293ff34179f21899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d67e207b3d753ab71b3801981cfeff3"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return &gt; </td></tr>
<tr class="memitem:ga0d67e207b3d753ab71b3801981cfeff3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1pointer__functor2.html">pointer_functor2</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_return &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga0d67e207b3d753ab71b3801981cfeff3">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor2.html">pointer_functor2</a>&lt; T_arg1, T_arg2, T_return &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga0d67e207b3d753ab71b3801981cfeff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga0d67e207b3d753ab71b3801981cfeff3"></a><br/></td></tr>
<tr class="separator:ga0d67e207b3d753ab71b3801981cfeff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5dfa926e3bfc7b82e0d14e4d9c9ff32"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return &gt; </td></tr>
<tr class="memitem:gaa5dfa926e3bfc7b82e0d14e4d9c9ff32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1pointer__functor3.html">pointer_functor3</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_return &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gaa5dfa926e3bfc7b82e0d14e4d9c9ff32">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor3.html">pointer_functor3</a>&lt; T_arg1, T_arg2, T_arg3, T_return &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gaa5dfa926e3bfc7b82e0d14e4d9c9ff32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gaa5dfa926e3bfc7b82e0d14e4d9c9ff32"></a><br/></td></tr>
<tr class="separator:gaa5dfa926e3bfc7b82e0d14e4d9c9ff32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade02a3d76cf35465acfa39d4e03a40d5"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return &gt; </td></tr>
<tr class="memitem:gade02a3d76cf35465acfa39d4e03a40d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1pointer__functor4.html">pointer_functor4</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_return &gt;, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gade02a3d76cf35465acfa39d4e03a40d5">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor4.html">pointer_functor4</a>&lt; T_arg1, T_arg2, T_arg3, T_arg4, T_return &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gade02a3d76cf35465acfa39d4e03a40d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gade02a3d76cf35465acfa39d4e03a40d5"></a><br/></td></tr>
<tr class="separator:gade02a3d76cf35465acfa39d4e03a40d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45fa726d6497c6b0994444fd2569581c"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return &gt; </td></tr>
<tr class="memitem:ga45fa726d6497c6b0994444fd2569581c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1pointer__functor5.html">pointer_functor5</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_return &gt;, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga45fa726d6497c6b0994444fd2569581c">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor5.html">pointer_functor5</a>&lt; T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_return &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga45fa726d6497c6b0994444fd2569581c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga45fa726d6497c6b0994444fd2569581c"></a><br/></td></tr>
<tr class="separator:ga45fa726d6497c6b0994444fd2569581c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24e30de09c3784220829f52bb068b8c0"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return &gt; </td></tr>
<tr class="memitem:ga24e30de09c3784220829f52bb068b8c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1pointer__functor6.html">pointer_functor6</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_return &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga24e30de09c3784220829f52bb068b8c0">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor6.html">pointer_functor6</a>&lt; T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_return &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga24e30de09c3784220829f52bb068b8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga24e30de09c3784220829f52bb068b8c0"></a><br/></td></tr>
<tr class="separator:ga24e30de09c3784220829f52bb068b8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09db0b458651a7fcd985e5dd4e50caa0"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return &gt; </td></tr>
<tr class="memitem:ga09db0b458651a7fcd985e5dd4e50caa0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1pointer__functor7.html">pointer_functor7</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7, T_return &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga09db0b458651a7fcd985e5dd4e50caa0">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor7.html">pointer_functor7</a>&lt; T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, T_return &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga09db0b458651a7fcd985e5dd4e50caa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga09db0b458651a7fcd985e5dd4e50caa0"></a><br/></td></tr>
<tr class="separator:ga09db0b458651a7fcd985e5dd4e50caa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb08dd87f3ec392536b656b6b3e959a0"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gabb08dd87f3ec392536b656b6b3e959a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gabb08dd87f3ec392536b656b6b3e959a0">retype</a> (const <a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gabb08dd87f3ec392536b656b6b3e959a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gabb08dd87f3ec392536b656b6b3e959a0"></a><br/></td></tr>
<tr class="separator:gabb08dd87f3ec392536b656b6b3e959a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a2600190453d4eb11c14f99973044bc"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr class="memitem:ga5a2600190453d4eb11c14f99973044bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;<br class="typebreak"/>
, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga5a2600190453d4eb11c14f99973044bc">retype</a> (const <a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga5a2600190453d4eb11c14f99973044bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga5a2600190453d4eb11c14f99973044bc"></a><br/></td></tr>
<tr class="separator:ga5a2600190453d4eb11c14f99973044bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7df338186f09b1c89c2840f6744362e9"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:ga7df338186f09b1c89c2840f6744362e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga7df338186f09b1c89c2840f6744362e9">retype</a> (const <a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga7df338186f09b1c89c2840f6744362e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga7df338186f09b1c89c2840f6744362e9"></a><br/></td></tr>
<tr class="separator:ga7df338186f09b1c89c2840f6744362e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2d9d2e91b2f8d256e4ad8da1c3c59e0"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr class="memitem:gae2d9d2e91b2f8d256e4ad8da1c3c59e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gae2d9d2e91b2f8d256e4ad8da1c3c59e0">retype</a> (const <a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gae2d9d2e91b2f8d256e4ad8da1c3c59e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gae2d9d2e91b2f8d256e4ad8da1c3c59e0"></a><br/></td></tr>
<tr class="separator:gae2d9d2e91b2f8d256e4ad8da1c3c59e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70e615639e07e90a997a378cf877b106"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr class="memitem:ga70e615639e07e90a997a378cf877b106"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga70e615639e07e90a997a378cf877b106">retype</a> (const <a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga70e615639e07e90a997a378cf877b106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga70e615639e07e90a997a378cf877b106"></a><br/></td></tr>
<tr class="separator:ga70e615639e07e90a997a378cf877b106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad225dee1d71c68d0ee71f3f0fedcfc1b"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr class="memitem:gad225dee1d71c68d0ee71f3f0fedcfc1b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gad225dee1d71c68d0ee71f3f0fedcfc1b">retype</a> (const <a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gad225dee1d71c68d0ee71f3f0fedcfc1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gad225dee1d71c68d0ee71f3f0fedcfc1b"></a><br/></td></tr>
<tr class="separator:gad225dee1d71c68d0ee71f3f0fedcfc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c08fe50076854f15c923ab4183aed0f"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr class="memitem:ga9c08fe50076854f15c923ab4183aed0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga9c08fe50076854f15c923ab4183aed0f">retype</a> (const <a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga9c08fe50076854f15c923ab4183aed0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga9c08fe50076854f15c923ab4183aed0f"></a><br/></td></tr>
<tr class="separator:ga9c08fe50076854f15c923ab4183aed0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fbd72b71a4ea4fafa487b5932acd797"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr class="memitem:ga3fbd72b71a4ea4fafa487b5932acd797"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga3fbd72b71a4ea4fafa487b5932acd797">retype</a> (const <a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga3fbd72b71a4ea4fafa487b5932acd797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga3fbd72b71a4ea4fafa487b5932acd797"></a><br/></td></tr>
<tr class="separator:ga3fbd72b71a4ea4fafa487b5932acd797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0688ca8eb3ee82e191563ba7f81366b2"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga0688ca8eb3ee82e191563ba7f81366b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__mem__functor0.html">const_mem_functor0</a>&lt; T_return, <br class="typebreak"/>
T_obj &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga0688ca8eb3ee82e191563ba7f81366b2">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor0.html">const_mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga0688ca8eb3ee82e191563ba7f81366b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga0688ca8eb3ee82e191563ba7f81366b2"></a><br/></td></tr>
<tr class="separator:ga0688ca8eb3ee82e191563ba7f81366b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae035134414ed79a187a6b41a115a3759"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr class="memitem:gae035134414ed79a187a6b41a115a3759"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__mem__functor1.html">const_mem_functor1</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1 &gt;, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gae035134414ed79a187a6b41a115a3759">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor1.html">const_mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gae035134414ed79a187a6b41a115a3759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gae035134414ed79a187a6b41a115a3759"></a><br/></td></tr>
<tr class="separator:gae035134414ed79a187a6b41a115a3759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e9ee582f601451f3aa7c3d37d03b952"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:ga8e9ee582f601451f3aa7c3d37d03b952"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__mem__functor2.html">const_mem_functor2</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2 &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga8e9ee582f601451f3aa7c3d37d03b952">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor2.html">const_mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga8e9ee582f601451f3aa7c3d37d03b952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga8e9ee582f601451f3aa7c3d37d03b952"></a><br/></td></tr>
<tr class="separator:ga8e9ee582f601451f3aa7c3d37d03b952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81e06b857f7a44b0589125e28535f87f"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr class="memitem:ga81e06b857f7a44b0589125e28535f87f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__mem__functor3.html">const_mem_functor3</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga81e06b857f7a44b0589125e28535f87f">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor3.html">const_mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga81e06b857f7a44b0589125e28535f87f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga81e06b857f7a44b0589125e28535f87f"></a><br/></td></tr>
<tr class="separator:ga81e06b857f7a44b0589125e28535f87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga411bdd3476f80d627c50d47149862ec2"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr class="memitem:ga411bdd3476f80d627c50d47149862ec2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__mem__functor4.html">const_mem_functor4</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga411bdd3476f80d627c50d47149862ec2">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor4.html">const_mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga411bdd3476f80d627c50d47149862ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga411bdd3476f80d627c50d47149862ec2"></a><br/></td></tr>
<tr class="separator:ga411bdd3476f80d627c50d47149862ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga995053759ee8ee89663f9625a4aaf596"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr class="memitem:ga995053759ee8ee89663f9625a4aaf596"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__mem__functor5.html">const_mem_functor5</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga995053759ee8ee89663f9625a4aaf596">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor5.html">const_mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga995053759ee8ee89663f9625a4aaf596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga995053759ee8ee89663f9625a4aaf596"></a><br/></td></tr>
<tr class="separator:ga995053759ee8ee89663f9625a4aaf596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga851188153c54bb1eb8fee425f9796981"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr class="memitem:ga851188153c54bb1eb8fee425f9796981"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__mem__functor6.html">const_mem_functor6</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga851188153c54bb1eb8fee425f9796981">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor6.html">const_mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga851188153c54bb1eb8fee425f9796981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga851188153c54bb1eb8fee425f9796981"></a><br/></td></tr>
<tr class="separator:ga851188153c54bb1eb8fee425f9796981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa951debcabd066f8c3479617aaa9689e"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr class="memitem:gaa951debcabd066f8c3479617aaa9689e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__mem__functor7.html">const_mem_functor7</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gaa951debcabd066f8c3479617aaa9689e">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor7.html">const_mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gaa951debcabd066f8c3479617aaa9689e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gaa951debcabd066f8c3479617aaa9689e"></a><br/></td></tr>
<tr class="separator:gaa951debcabd066f8c3479617aaa9689e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53d620659c82cbb84da3812ac874f4b7"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga53d620659c82cbb84da3812ac874f4b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1volatile__mem__functor0.html">volatile_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga53d620659c82cbb84da3812ac874f4b7">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor0.html">volatile_mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga53d620659c82cbb84da3812ac874f4b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga53d620659c82cbb84da3812ac874f4b7"></a><br/></td></tr>
<tr class="separator:ga53d620659c82cbb84da3812ac874f4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d7f05b930056183bc7537447c80e59b"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr class="memitem:ga6d7f05b930056183bc7537447c80e59b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1volatile__mem__functor1.html">volatile_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;<br class="typebreak"/>
, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga6d7f05b930056183bc7537447c80e59b">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor1.html">volatile_mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga6d7f05b930056183bc7537447c80e59b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga6d7f05b930056183bc7537447c80e59b"></a><br/></td></tr>
<tr class="separator:ga6d7f05b930056183bc7537447c80e59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b65e9a9794300c40b1577302e006fbd"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:ga5b65e9a9794300c40b1577302e006fbd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1volatile__mem__functor2.html">volatile_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga5b65e9a9794300c40b1577302e006fbd">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor2.html">volatile_mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga5b65e9a9794300c40b1577302e006fbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga5b65e9a9794300c40b1577302e006fbd"></a><br/></td></tr>
<tr class="separator:ga5b65e9a9794300c40b1577302e006fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55236721b80a72f40453d1b939316635"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr class="memitem:ga55236721b80a72f40453d1b939316635"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1volatile__mem__functor3.html">volatile_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga55236721b80a72f40453d1b939316635">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor3.html">volatile_mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga55236721b80a72f40453d1b939316635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga55236721b80a72f40453d1b939316635"></a><br/></td></tr>
<tr class="separator:ga55236721b80a72f40453d1b939316635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05d2c3c043bed420ba8ba6f40f42f692"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr class="memitem:ga05d2c3c043bed420ba8ba6f40f42f692"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1volatile__mem__functor4.html">volatile_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga05d2c3c043bed420ba8ba6f40f42f692">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor4.html">volatile_mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga05d2c3c043bed420ba8ba6f40f42f692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga05d2c3c043bed420ba8ba6f40f42f692"></a><br/></td></tr>
<tr class="separator:ga05d2c3c043bed420ba8ba6f40f42f692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42be2d2fbf03fbaba1ad7d8cbbb8bce4"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr class="memitem:ga42be2d2fbf03fbaba1ad7d8cbbb8bce4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1volatile__mem__functor5.html">volatile_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga42be2d2fbf03fbaba1ad7d8cbbb8bce4">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor5.html">volatile_mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga42be2d2fbf03fbaba1ad7d8cbbb8bce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga42be2d2fbf03fbaba1ad7d8cbbb8bce4"></a><br/></td></tr>
<tr class="separator:ga42be2d2fbf03fbaba1ad7d8cbbb8bce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga255fac4b456d69d033b327b1d533f054"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr class="memitem:ga255fac4b456d69d033b327b1d533f054"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1volatile__mem__functor6.html">volatile_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga255fac4b456d69d033b327b1d533f054">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor6.html">volatile_mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga255fac4b456d69d033b327b1d533f054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga255fac4b456d69d033b327b1d533f054"></a><br/></td></tr>
<tr class="separator:ga255fac4b456d69d033b327b1d533f054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37a057f88e6ffbb8d4172d6446116796"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr class="memitem:ga37a057f88e6ffbb8d4172d6446116796"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1volatile__mem__functor7.html">volatile_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga37a057f88e6ffbb8d4172d6446116796">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor7.html">volatile_mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga37a057f88e6ffbb8d4172d6446116796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga37a057f88e6ffbb8d4172d6446116796"></a><br/></td></tr>
<tr class="separator:ga37a057f88e6ffbb8d4172d6446116796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga312fca59eb8b4ca0e078b1cf7f407212"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga312fca59eb8b4ca0e078b1cf7f407212"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">const_volatile_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga312fca59eb8b4ca0e078b1cf7f407212">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">const_volatile_mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga312fca59eb8b4ca0e078b1cf7f407212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga312fca59eb8b4ca0e078b1cf7f407212"></a><br/></td></tr>
<tr class="separator:ga312fca59eb8b4ca0e078b1cf7f407212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84f4247ab4cc559aed835ccd943fab70"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr class="memitem:ga84f4247ab4cc559aed835ccd943fab70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">const_volatile_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;<br class="typebreak"/>
, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga84f4247ab4cc559aed835ccd943fab70">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">const_volatile_mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga84f4247ab4cc559aed835ccd943fab70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga84f4247ab4cc559aed835ccd943fab70"></a><br/></td></tr>
<tr class="separator:ga84f4247ab4cc559aed835ccd943fab70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga271911579dfbac317a53f62f0773e420"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:ga271911579dfbac317a53f62f0773e420"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">const_volatile_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga271911579dfbac317a53f62f0773e420">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">const_volatile_mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga271911579dfbac317a53f62f0773e420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga271911579dfbac317a53f62f0773e420"></a><br/></td></tr>
<tr class="separator:ga271911579dfbac317a53f62f0773e420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97b4f14b5a7991eba60b635871d6a7f9"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr class="memitem:ga97b4f14b5a7991eba60b635871d6a7f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">const_volatile_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga97b4f14b5a7991eba60b635871d6a7f9">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">const_volatile_mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga97b4f14b5a7991eba60b635871d6a7f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga97b4f14b5a7991eba60b635871d6a7f9"></a><br/></td></tr>
<tr class="separator:ga97b4f14b5a7991eba60b635871d6a7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e9179cc61db0069db209bc7632b3dee"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr class="memitem:ga4e9179cc61db0069db209bc7632b3dee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">const_volatile_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga4e9179cc61db0069db209bc7632b3dee">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">const_volatile_mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga4e9179cc61db0069db209bc7632b3dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga4e9179cc61db0069db209bc7632b3dee"></a><br/></td></tr>
<tr class="separator:ga4e9179cc61db0069db209bc7632b3dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga637af7b3e60f5657dcd62e350ec76675"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr class="memitem:ga637af7b3e60f5657dcd62e350ec76675"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">const_volatile_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga637af7b3e60f5657dcd62e350ec76675">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">const_volatile_mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga637af7b3e60f5657dcd62e350ec76675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga637af7b3e60f5657dcd62e350ec76675"></a><br/></td></tr>
<tr class="separator:ga637af7b3e60f5657dcd62e350ec76675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17ceafe96cdf3bd37ccd401f413f8748"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr class="memitem:ga17ceafe96cdf3bd37ccd401f413f8748"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">const_volatile_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga17ceafe96cdf3bd37ccd401f413f8748">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">const_volatile_mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga17ceafe96cdf3bd37ccd401f413f8748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga17ceafe96cdf3bd37ccd401f413f8748"></a><br/></td></tr>
<tr class="separator:ga17ceafe96cdf3bd37ccd401f413f8748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75578233ce4f47c5f610569a5ffe84cc"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr class="memitem:ga75578233ce4f47c5f610569a5ffe84cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">const_volatile_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga75578233ce4f47c5f610569a5ffe84cc">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">const_volatile_mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga75578233ce4f47c5f610569a5ffe84cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga75578233ce4f47c5f610569a5ffe84cc"></a><br/></td></tr>
<tr class="separator:ga75578233ce4f47c5f610569a5ffe84cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebe9c150af92e230257bbbdb728e5a07"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gaebe9c150af92e230257bbbdb728e5a07"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a>&lt; T_return, <br class="typebreak"/>
T_obj &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gaebe9c150af92e230257bbbdb728e5a07">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gaebe9c150af92e230257bbbdb728e5a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gaebe9c150af92e230257bbbdb728e5a07"></a><br/></td></tr>
<tr class="separator:gaebe9c150af92e230257bbbdb728e5a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga971017d74a880ee10555ebd32483d188"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr class="memitem:ga971017d74a880ee10555ebd32483d188"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1 &gt;, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga971017d74a880ee10555ebd32483d188">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga971017d74a880ee10555ebd32483d188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga971017d74a880ee10555ebd32483d188"></a><br/></td></tr>
<tr class="separator:ga971017d74a880ee10555ebd32483d188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddf62506fc01f1cdfcadef27e47f9b59"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:gaddf62506fc01f1cdfcadef27e47f9b59"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2 &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gaddf62506fc01f1cdfcadef27e47f9b59">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gaddf62506fc01f1cdfcadef27e47f9b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gaddf62506fc01f1cdfcadef27e47f9b59"></a><br/></td></tr>
<tr class="separator:gaddf62506fc01f1cdfcadef27e47f9b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad916eb17d984df3b7da9b7d3d041168a"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr class="memitem:gad916eb17d984df3b7da9b7d3d041168a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gad916eb17d984df3b7da9b7d3d041168a">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gad916eb17d984df3b7da9b7d3d041168a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gad916eb17d984df3b7da9b7d3d041168a"></a><br/></td></tr>
<tr class="separator:gad916eb17d984df3b7da9b7d3d041168a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8362fa71a99b71b843205e0482b281fc"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr class="memitem:ga8362fa71a99b71b843205e0482b281fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga8362fa71a99b71b843205e0482b281fc">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga8362fa71a99b71b843205e0482b281fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga8362fa71a99b71b843205e0482b281fc"></a><br/></td></tr>
<tr class="separator:ga8362fa71a99b71b843205e0482b281fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c139b3254f5020de44a73c7dd795819"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr class="memitem:ga9c139b3254f5020de44a73c7dd795819"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga9c139b3254f5020de44a73c7dd795819">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga9c139b3254f5020de44a73c7dd795819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga9c139b3254f5020de44a73c7dd795819"></a><br/></td></tr>
<tr class="separator:ga9c139b3254f5020de44a73c7dd795819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12e152b4340f83bd1f6cec92771fa82a"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr class="memitem:ga12e152b4340f83bd1f6cec92771fa82a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga12e152b4340f83bd1f6cec92771fa82a">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga12e152b4340f83bd1f6cec92771fa82a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga12e152b4340f83bd1f6cec92771fa82a"></a><br/></td></tr>
<tr class="separator:ga12e152b4340f83bd1f6cec92771fa82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadda8029b543d9b657f01e6ba9a9ef8fd"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr class="memitem:gadda8029b543d9b657f01e6ba9a9ef8fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gadda8029b543d9b657f01e6ba9a9ef8fd">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gadda8029b543d9b657f01e6ba9a9ef8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gadda8029b543d9b657f01e6ba9a9ef8fd"></a><br/></td></tr>
<tr class="separator:gadda8029b543d9b657f01e6ba9a9ef8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31061f134d93297fd0b4f2d56efafbe3"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga31061f134d93297fd0b4f2d56efafbe3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga31061f134d93297fd0b4f2d56efafbe3">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga31061f134d93297fd0b4f2d56efafbe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga31061f134d93297fd0b4f2d56efafbe3"></a><br/></td></tr>
<tr class="separator:ga31061f134d93297fd0b4f2d56efafbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63ead6c4883a6553446594e6027dc96c"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr class="memitem:ga63ead6c4883a6553446594e6027dc96c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;<br class="typebreak"/>
, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga63ead6c4883a6553446594e6027dc96c">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga63ead6c4883a6553446594e6027dc96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga63ead6c4883a6553446594e6027dc96c"></a><br/></td></tr>
<tr class="separator:ga63ead6c4883a6553446594e6027dc96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga415bd3f44f1785ce30452a4ca8e46dd0"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:ga415bd3f44f1785ce30452a4ca8e46dd0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga415bd3f44f1785ce30452a4ca8e46dd0">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga415bd3f44f1785ce30452a4ca8e46dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga415bd3f44f1785ce30452a4ca8e46dd0"></a><br/></td></tr>
<tr class="separator:ga415bd3f44f1785ce30452a4ca8e46dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f86026b9959cdd62287b29407c71e97"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr class="memitem:ga6f86026b9959cdd62287b29407c71e97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga6f86026b9959cdd62287b29407c71e97">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga6f86026b9959cdd62287b29407c71e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga6f86026b9959cdd62287b29407c71e97"></a><br/></td></tr>
<tr class="separator:ga6f86026b9959cdd62287b29407c71e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fbc58cc94f7f4a46c1557091974a278"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr class="memitem:ga8fbc58cc94f7f4a46c1557091974a278"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga8fbc58cc94f7f4a46c1557091974a278">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga8fbc58cc94f7f4a46c1557091974a278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga8fbc58cc94f7f4a46c1557091974a278"></a><br/></td></tr>
<tr class="separator:ga8fbc58cc94f7f4a46c1557091974a278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d0d963fa703a6f85b8002c3a405c00a"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr class="memitem:ga1d0d963fa703a6f85b8002c3a405c00a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga1d0d963fa703a6f85b8002c3a405c00a">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga1d0d963fa703a6f85b8002c3a405c00a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga1d0d963fa703a6f85b8002c3a405c00a"></a><br/></td></tr>
<tr class="separator:ga1d0d963fa703a6f85b8002c3a405c00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39ba6af86d75de1535e4fa8af1e6081b"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr class="memitem:ga39ba6af86d75de1535e4fa8af1e6081b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga39ba6af86d75de1535e4fa8af1e6081b">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga39ba6af86d75de1535e4fa8af1e6081b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga39ba6af86d75de1535e4fa8af1e6081b"></a><br/></td></tr>
<tr class="separator:ga39ba6af86d75de1535e4fa8af1e6081b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02a44f2ea2386f8e4fa41cb582c2008d"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr class="memitem:ga02a44f2ea2386f8e4fa41cb582c2008d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga02a44f2ea2386f8e4fa41cb582c2008d">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga02a44f2ea2386f8e4fa41cb582c2008d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga02a44f2ea2386f8e4fa41cb582c2008d"></a><br/></td></tr>
<tr class="separator:ga02a44f2ea2386f8e4fa41cb582c2008d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc01bb77132048902ec8965d012edcd3"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gadc01bb77132048902ec8965d012edcd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gadc01bb77132048902ec8965d012edcd3">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gadc01bb77132048902ec8965d012edcd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gadc01bb77132048902ec8965d012edcd3"></a><br/></td></tr>
<tr class="separator:gadc01bb77132048902ec8965d012edcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45b921820c277072b6f7e856ddbcfca1"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr class="memitem:ga45b921820c277072b6f7e856ddbcfca1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;<br class="typebreak"/>
, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga45b921820c277072b6f7e856ddbcfca1">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga45b921820c277072b6f7e856ddbcfca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga45b921820c277072b6f7e856ddbcfca1"></a><br/></td></tr>
<tr class="separator:ga45b921820c277072b6f7e856ddbcfca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf420d79b4077b848ef1aef4b68810d6e"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:gaf420d79b4077b848ef1aef4b68810d6e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gaf420d79b4077b848ef1aef4b68810d6e">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gaf420d79b4077b848ef1aef4b68810d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gaf420d79b4077b848ef1aef4b68810d6e"></a><br/></td></tr>
<tr class="separator:gaf420d79b4077b848ef1aef4b68810d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga899ae79da0e918ad9fc8f2c8e8066218"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr class="memitem:ga899ae79da0e918ad9fc8f2c8e8066218"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga899ae79da0e918ad9fc8f2c8e8066218">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga899ae79da0e918ad9fc8f2c8e8066218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga899ae79da0e918ad9fc8f2c8e8066218"></a><br/></td></tr>
<tr class="separator:ga899ae79da0e918ad9fc8f2c8e8066218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8540037bfd4da57495b60dd9487c6d0b"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr class="memitem:ga8540037bfd4da57495b60dd9487c6d0b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga8540037bfd4da57495b60dd9487c6d0b">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga8540037bfd4da57495b60dd9487c6d0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga8540037bfd4da57495b60dd9487c6d0b"></a><br/></td></tr>
<tr class="separator:ga8540037bfd4da57495b60dd9487c6d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31ace8220cbb70b8e7f545ee4c1b6610"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr class="memitem:ga31ace8220cbb70b8e7f545ee4c1b6610"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga31ace8220cbb70b8e7f545ee4c1b6610">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga31ace8220cbb70b8e7f545ee4c1b6610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga31ace8220cbb70b8e7f545ee4c1b6610"></a><br/></td></tr>
<tr class="separator:ga31ace8220cbb70b8e7f545ee4c1b6610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f45f05c95abc9d20ae9d39589f5d72e"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr class="memitem:ga9f45f05c95abc9d20ae9d39589f5d72e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga9f45f05c95abc9d20ae9d39589f5d72e">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga9f45f05c95abc9d20ae9d39589f5d72e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga9f45f05c95abc9d20ae9d39589f5d72e"></a><br/></td></tr>
<tr class="separator:ga9f45f05c95abc9d20ae9d39589f5d72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17e8761db2fafa2d3a92d19d8ce47511"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr class="memitem:ga17e8761db2fafa2d3a92d19d8ce47511"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga17e8761db2fafa2d3a92d19d8ce47511">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga17e8761db2fafa2d3a92d19d8ce47511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga17e8761db2fafa2d3a92d19d8ce47511"></a><br/></td></tr>
<tr class="separator:ga17e8761db2fafa2d3a92d19d8ce47511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade9ed42b368ea6eee6d42c8116cd28dd"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gade9ed42b368ea6eee6d42c8116cd28dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gade9ed42b368ea6eee6d42c8116cd28dd">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gade9ed42b368ea6eee6d42c8116cd28dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gade9ed42b368ea6eee6d42c8116cd28dd"></a><br/></td></tr>
<tr class="separator:gade9ed42b368ea6eee6d42c8116cd28dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab22de279058fd53d5ef720ad3932b56"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr class="memitem:gaab22de279058fd53d5ef720ad3932b56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;<br class="typebreak"/>
, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gaab22de279058fd53d5ef720ad3932b56">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gaab22de279058fd53d5ef720ad3932b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gaab22de279058fd53d5ef720ad3932b56"></a><br/></td></tr>
<tr class="separator:gaab22de279058fd53d5ef720ad3932b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42f7c6ae10273b6577909f89bd76dc1f"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:ga42f7c6ae10273b6577909f89bd76dc1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga42f7c6ae10273b6577909f89bd76dc1f">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga42f7c6ae10273b6577909f89bd76dc1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga42f7c6ae10273b6577909f89bd76dc1f"></a><br/></td></tr>
<tr class="separator:ga42f7c6ae10273b6577909f89bd76dc1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b2477c6ed3347fae35c66f25977f9dc"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr class="memitem:ga1b2477c6ed3347fae35c66f25977f9dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga1b2477c6ed3347fae35c66f25977f9dc">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga1b2477c6ed3347fae35c66f25977f9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga1b2477c6ed3347fae35c66f25977f9dc"></a><br/></td></tr>
<tr class="separator:ga1b2477c6ed3347fae35c66f25977f9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad73b9445fab1544d7550db964426520d"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr class="memitem:gad73b9445fab1544d7550db964426520d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gad73b9445fab1544d7550db964426520d">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gad73b9445fab1544d7550db964426520d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gad73b9445fab1544d7550db964426520d"></a><br/></td></tr>
<tr class="separator:gad73b9445fab1544d7550db964426520d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbb4a1e1c3447205bf507d6912847015"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr class="memitem:gacbb4a1e1c3447205bf507d6912847015"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gacbb4a1e1c3447205bf507d6912847015">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gacbb4a1e1c3447205bf507d6912847015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gacbb4a1e1c3447205bf507d6912847015"></a><br/></td></tr>
<tr class="separator:gacbb4a1e1c3447205bf507d6912847015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace1ef4f9ca35373adaad3c29db2b918f"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr class="memitem:gace1ef4f9ca35373adaad3c29db2b918f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gace1ef4f9ca35373adaad3c29db2b918f">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gace1ef4f9ca35373adaad3c29db2b918f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#gace1ef4f9ca35373adaad3c29db2b918f"></a><br/></td></tr>
<tr class="separator:gace1ef4f9ca35373adaad3c29db2b918f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ec0f19b59050f8f01c8969835b3c742"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr class="memitem:ga1ec0f19b59050f8f01c8969835b3c742"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga1ec0f19b59050f8f01c8969835b3c742">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga1ec0f19b59050f8f01c8969835b3c742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor.">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor. <a href="group__retype.html#ga1ec0f19b59050f8f01c8969835b3c742"></a><br/></td></tr>
<tr class="separator:ga1ec0f19b59050f8f01c8969835b3c742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7db81a28c43ca8fecc448c9c6f7a17d"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_setter , class T_getter &gt; </td></tr>
<tr class="memitem:gab7db81a28c43ca8fecc448c9c6f7a17d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compose.html#gab7db81a28c43ca8fecc448c9c6f7a17d">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1compose1__functor.html">compose1_functor</a>&lt; T_setter, T_getter &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:gab7db81a28c43ca8fecc448c9c6f7a17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__compose.html#gab7db81a28c43ca8fecc448c9c6f7a17d"></a><br/></td></tr>
<tr class="separator:gab7db81a28c43ca8fecc448c9c6f7a17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9aca4eabaf81b92b2cbb5c7a4ebfbb33"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_setter , class T_getter1 , class T_getter2 &gt; </td></tr>
<tr class="memitem:ga9aca4eabaf81b92b2cbb5c7a4ebfbb33"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compose.html#ga9aca4eabaf81b92b2cbb5c7a4ebfbb33">visit_each</a> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1compose2__functor.html">compose2_functor</a>&lt; T_setter, T_getter1, T_getter2 &gt;&amp; _A_target)</td></tr>
<tr class="memdesc:ga9aca4eabaf81b92b2cbb5c7a4ebfbb33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a functor on each of the targets of a functor. <a href="group__compose.html#ga9aca4eabaf81b92b2cbb5c7a4ebfbb33"></a><br/></td></tr>
<tr class="separator:ga9aca4eabaf81b92b2cbb5c7a4ebfbb33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34cf5da8f6323bfdc41bc7113d6ad20a"><td class="memTemplParams" colspan="2">template&lt;class T_setter , class T_getter &gt; </td></tr>
<tr class="memitem:ga34cf5da8f6323bfdc41bc7113d6ad20a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1compose1__functor.html">compose1_functor</a>&lt; T_setter, <br class="typebreak"/>
T_getter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compose.html#ga34cf5da8f6323bfdc41bc7113d6ad20a">compose</a> (const T_setter&amp; _A_setter, const T_getter&amp; _A_getter)</td></tr>
<tr class="memdesc:ga34cf5da8f6323bfdc41bc7113d6ad20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1compose1__functor.html" title="Adaptor that combines two functors.">sigc::compose1_functor</a> which combines two functors. <a href="group__compose.html#ga34cf5da8f6323bfdc41bc7113d6ad20a"></a><br/></td></tr>
<tr class="separator:ga34cf5da8f6323bfdc41bc7113d6ad20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4abf2a45eb2307a3dc5d870c86b0450d"><td class="memTemplParams" colspan="2">template&lt;class T_setter , class T_getter1 , class T_getter2 &gt; </td></tr>
<tr class="memitem:ga4abf2a45eb2307a3dc5d870c86b0450d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1compose2__functor.html">compose2_functor</a>&lt; T_setter, <br class="typebreak"/>
T_getter1, T_getter2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compose.html#ga4abf2a45eb2307a3dc5d870c86b0450d">compose</a> (const T_setter&amp; _A_setter, const T_getter1&amp; _A_getter1, const T_getter2&amp; _A_getter2)</td></tr>
<tr class="memdesc:ga4abf2a45eb2307a3dc5d870c86b0450d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1compose2__functor.html" title="Adaptor that combines three functors.">sigc::compose2_functor</a> which combines three functors. <a href="group__compose.html#ga4abf2a45eb2307a3dc5d870c86b0450d"></a><br/></td></tr>
<tr class="separator:ga4abf2a45eb2307a3dc5d870c86b0450d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb0da0e318840c0d5f6a4eb680fb87b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2bb0da0e318840c0d5f6a4eb680fb87b"></a>
template &lt;class T_action , class T_functor , class T_catcher , class T_return &gt; </td></tr>
<tr class="memitem:a2bb0da0e318840c0d5f6a4eb680fb87b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>visit_each</b> (const T_action &amp;_A_action, const exception_catch_functor&lt; T_functor, T_catcher, T_return &gt; &amp;_A_target)</td></tr>
<tr class="separator:a2bb0da0e318840c0d5f6a4eb680fb87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae3b8a1ba26920cee4d7d9df2c39ed9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0ae3b8a1ba26920cee4d7d9df2c39ed9"></a>
template &lt;class T_functor , class T_catcher &gt; </td></tr>
<tr class="memitem:a0ae3b8a1ba26920cee4d7d9df2c39ed9"><td class="memTemplItemLeft" align="right" valign="top">exception_catch_functor<br class="typebreak"/>
&lt; T_functor, T_catcher &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exception_catch</b> (const T_functor &amp;_A_func, const T_catcher &amp;_A_catcher)</td></tr>
<tr class="separator:a0ae3b8a1ba26920cee4d7d9df2c39ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3408fab02ec1883e982635be7765379"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac3408fab02ec1883e982635be7765379"></a>
template &lt;class T_action , class T_functor , bool I_islambda&gt; </td></tr>
<tr class="memitem:ac3408fab02ec1883e982635be7765379"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>visit_each</b> (const T_action &amp;_A_action, const internal::lambda_core&lt; T_functor, I_islambda &gt; &amp;_A_target)</td></tr>
<tr class="separator:ac3408fab02ec1883e982635be7765379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbbd890bbed369b5a77ef375a34ab47"><td class="memTemplParams" colspan="2">template&lt;class T_type &gt; </td></tr>
<tr class="memitem:a5fbbd890bbed369b5a77ef375a34ab47"><td class="memTemplItemLeft" align="right" valign="top">T_type&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a5fbbd890bbed369b5a77ef375a34ab47">unwrap_lambda_value</a> (T_type&amp; a)</td></tr>
<tr class="memdesc:a5fbbd890bbed369b5a77ef375a34ab47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the object stored inside a lambda object. <a href="#a5fbbd890bbed369b5a77ef375a34ab47"></a><br/></td></tr>
<tr class="separator:a5fbbd890bbed369b5a77ef375a34ab47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23fcae89c45fa2f28ed2ed421b2249ca"><td class="memTemplParams" colspan="2"><a class="anchor" id="a23fcae89c45fa2f28ed2ed421b2249ca"></a>
template &lt;class T_type &gt; </td></tr>
<tr class="memitem:a23fcae89c45fa2f28ed2ed421b2249ca"><td class="memTemplItemLeft" align="right" valign="top">const T_type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unwrap_lambda_value</b> (const T_type &amp;a)</td></tr>
<tr class="separator:a23fcae89c45fa2f28ed2ed421b2249ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075ab6d364e385be8ff683fb6c24151f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a075ab6d364e385be8ff683fb6c24151f"></a>
template &lt;class T_type &gt; </td></tr>
<tr class="memitem:a075ab6d364e385be8ff683fb6c24151f"><td class="memTemplItemLeft" align="right" valign="top">const T_type&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unwrap_lambda_value</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_type &gt;&amp; a)</td></tr>
<tr class="separator:a075ab6d364e385be8ff683fb6c24151f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af742bc109adc5362cf1992b2636fe3fd"><td class="memTemplParams" colspan="2"><a class="anchor" id="af742bc109adc5362cf1992b2636fe3fd"></a>
template &lt;class T_action , class T_type &gt; </td></tr>
<tr class="memitem:af742bc109adc5362cf1992b2636fe3fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>visit_each</b> (const T_action&amp; _A_action, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_type &gt;&amp; _A_target)</td></tr>
<tr class="separator:af742bc109adc5362cf1992b2636fe3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e560e6113af0c1e9f462471c1d502d4"><td class="memTemplParams" colspan="2">template&lt;class T_type &gt; </td></tr>
<tr class="memitem:a8e560e6113af0c1e9f462471c1d502d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_type&amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a8e560e6113af0c1e9f462471c1d502d4">var</a> (T_type&amp; v)</td></tr>
<tr class="memdesc:a8e560e6113af0c1e9f462471c1d502d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a reference into a lambda object. <a href="#a8e560e6113af0c1e9f462471c1d502d4"></a><br/></td></tr>
<tr class="separator:a8e560e6113af0c1e9f462471c1d502d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c51a04bb54990fe3d508fa06e574249"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5c51a04bb54990fe3d508fa06e574249"></a>
template &lt;class T_type &gt; </td></tr>
<tr class="memitem:a5c51a04bb54990fe3d508fa06e574249"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; const T_type&amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a5c51a04bb54990fe3d508fa06e574249">var</a> (const T_type&amp; v)</td></tr>
<tr class="memdesc:a5c51a04bb54990fe3d508fa06e574249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a constant reference into a lambda object. <br/></td></tr>
<tr class="separator:a5c51a04bb54990fe3d508fa06e574249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3675af3385991a1ed3249efed681fc"><td class="memTemplParams" colspan="2"><a class="anchor" id="abe3675af3385991a1ed3249efed681fc"></a>
template &lt;class T_action , class T_lambda_action , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:abe3675af3385991a1ed3249efed681fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>visit_each</b> (const T_action &amp;_A_action, const lambda_operator&lt;T_lambda_action, T_arg1, T_arg2 &gt; &amp;_A_target)</td></tr>
<tr class="separator:abe3675af3385991a1ed3249efed681fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b61a1bb3b59e21096e98cea13a3cffe"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4b61a1bb3b59e21096e98cea13a3cffe"></a>
template &lt;class T_action , class T_lambda_action , class T_arg &gt; </td></tr>
<tr class="memitem:a4b61a1bb3b59e21096e98cea13a3cffe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>visit_each</b> (const T_action &amp;_A_action, const lambda_operator_unary&lt; T_lambda_action, T_arg &gt; &amp;_A_target)</td></tr>
<tr class="separator:a4b61a1bb3b59e21096e98cea13a3cffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f6d5f05b1e3aad2b3fb599908dabbd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a90f6d5f05b1e3aad2b3fb599908dabbd"></a>
template &lt;class T_action , class T_lambda_action , class T_type , class T_arg &gt; </td></tr>
<tr class="memitem:a90f6d5f05b1e3aad2b3fb599908dabbd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>visit_each</b> (const T_action &amp;_A_action, const lambda_operator_convert&lt; T_lambda_action, T_type, T_arg &gt; &amp;_A_target)</td></tr>
<tr class="separator:a90f6d5f05b1e3aad2b3fb599908dabbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece652f1c93654d1709b31110790594e"><td class="memTemplParams" colspan="2"><a class="anchor" id="aece652f1c93654d1709b31110790594e"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:aece652f1c93654d1709b31110790594e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic&lt; plus &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:aece652f1c93654d1709b31110790594e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749a81a937c3dad366c17c4c5afacdba"><td class="memTemplParams" colspan="2"><a class="anchor" id="a749a81a937c3dad366c17c4c5afacdba"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a749a81a937c3dad366c17c4c5afacdba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic&lt; plus &gt;, T_arg1, <br class="typebreak"/>
typename unwrap_reference<br class="typebreak"/>
&lt; T_arg2 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr class="separator:a749a81a937c3dad366c17c4c5afacdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11dd5c52672e15dbc034d5fdeb42b4e2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a11dd5c52672e15dbc034d5fdeb42b4e2"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a11dd5c52672e15dbc034d5fdeb42b4e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic&lt; plus &gt;, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg1 &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a11dd5c52672e15dbc034d5fdeb42b4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae269ce20f50a72f272b1bd1532e56dbf"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae269ce20f50a72f272b1bd1532e56dbf"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:ae269ce20f50a72f272b1bd1532e56dbf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic&lt; minus &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:ae269ce20f50a72f272b1bd1532e56dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ddd1183094dae09ff86fb6852a56315"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7ddd1183094dae09ff86fb6852a56315"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a7ddd1183094dae09ff86fb6852a56315"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic&lt; minus &gt;, T_arg1, <br class="typebreak"/>
typename unwrap_reference<br class="typebreak"/>
&lt; T_arg2 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr class="separator:a7ddd1183094dae09ff86fb6852a56315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f59f1a88a74cc7bbbb1b6b6128b90dd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6f59f1a88a74cc7bbbb1b6b6128b90dd"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a6f59f1a88a74cc7bbbb1b6b6128b90dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic&lt; minus &gt;, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg1 &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a6f59f1a88a74cc7bbbb1b6b6128b90dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb36969505f78c295d08b3ab2abe70c1"><td class="memTemplParams" colspan="2"><a class="anchor" id="aeb36969505f78c295d08b3ab2abe70c1"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:aeb36969505f78c295d08b3ab2abe70c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic&lt; multiplies &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:aeb36969505f78c295d08b3ab2abe70c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5393558ec994460a2e9b1e4c8623c6f4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5393558ec994460a2e9b1e4c8623c6f4"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a5393558ec994460a2e9b1e4c8623c6f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic&lt; multiplies &gt;<br class="typebreak"/>
, T_arg1, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg2 &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr class="separator:a5393558ec994460a2e9b1e4c8623c6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc22e86cb92ba91f655e09067b6c924a"><td class="memTemplParams" colspan="2"><a class="anchor" id="afc22e86cb92ba91f655e09067b6c924a"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:afc22e86cb92ba91f655e09067b6c924a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic&lt; multiplies &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:afc22e86cb92ba91f655e09067b6c924a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbeb084c6660d5f1f6285361ead7b535"><td class="memTemplParams" colspan="2"><a class="anchor" id="adbeb084c6660d5f1f6285361ead7b535"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:adbeb084c6660d5f1f6285361ead7b535"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic&lt; divides &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:adbeb084c6660d5f1f6285361ead7b535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41980a06cb4cf6ed748bd2067079dd9"><td class="memTemplParams" colspan="2"><a class="anchor" id="af41980a06cb4cf6ed748bd2067079dd9"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:af41980a06cb4cf6ed748bd2067079dd9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic&lt; divides &gt;, T_arg1, <br class="typebreak"/>
typename unwrap_reference<br class="typebreak"/>
&lt; T_arg2 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr class="separator:af41980a06cb4cf6ed748bd2067079dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e47b6f332c33ac7ae117a355aa06a1b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4e47b6f332c33ac7ae117a355aa06a1b"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a4e47b6f332c33ac7ae117a355aa06a1b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic&lt; divides &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a4e47b6f332c33ac7ae117a355aa06a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac31d5f1d6fd216fb7d03446ce4a595"><td class="memTemplParams" colspan="2"><a class="anchor" id="adac31d5f1d6fd216fb7d03446ce4a595"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:adac31d5f1d6fd216fb7d03446ce4a595"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic&lt; modulus &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator%</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:adac31d5f1d6fd216fb7d03446ce4a595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9324730b8466875dc4f659c1a76bdb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6b9324730b8466875dc4f659c1a76bdb"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a6b9324730b8466875dc4f659c1a76bdb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic&lt; modulus &gt;, T_arg1, <br class="typebreak"/>
typename unwrap_reference<br class="typebreak"/>
&lt; T_arg2 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator%</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr class="separator:a6b9324730b8466875dc4f659c1a76bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71da95a29b9eeb095fc8ec722ab8a72"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae71da95a29b9eeb095fc8ec722ab8a72"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:ae71da95a29b9eeb095fc8ec722ab8a72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic&lt; modulus &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator%</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:ae71da95a29b9eeb095fc8ec722ab8a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3584311eaa01287d2e213feb263f82"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0b3584311eaa01287d2e213feb263f82"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a0b3584311eaa01287d2e213feb263f82"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise&lt; leftshift &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a0b3584311eaa01287d2e213feb263f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75adb515da1e2c1c22de08ea3f319028"><td class="memTemplParams" colspan="2"><a class="anchor" id="a75adb515da1e2c1c22de08ea3f319028"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a75adb515da1e2c1c22de08ea3f319028"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise&lt; leftshift &gt;, T_arg1, <br class="typebreak"/>
typename unwrap_reference<br class="typebreak"/>
&lt; T_arg2 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr class="separator:a75adb515da1e2c1c22de08ea3f319028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e0275766163180866ee4b1ed2bca75"><td class="memTemplParams" colspan="2"><a class="anchor" id="a50e0275766163180866ee4b1ed2bca75"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a50e0275766163180866ee4b1ed2bca75"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise&lt; leftshift &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a50e0275766163180866ee4b1ed2bca75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24004c40c61b89adc89be818935714e5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a24004c40c61b89adc89be818935714e5"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a24004c40c61b89adc89be818935714e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise&lt; rightshift &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a24004c40c61b89adc89be818935714e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6ee22e28968a210e44e3670cd487bf"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6a6ee22e28968a210e44e3670cd487bf"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a6a6ee22e28968a210e44e3670cd487bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise&lt; rightshift &gt;, T_arg1, <br class="typebreak"/>
typename unwrap_reference<br class="typebreak"/>
&lt; T_arg2 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr class="separator:a6a6ee22e28968a210e44e3670cd487bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7edc8f637e0eb4c7da29e378cc7c5a1d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7edc8f637e0eb4c7da29e378cc7c5a1d"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a7edc8f637e0eb4c7da29e378cc7c5a1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise&lt; rightshift &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a7edc8f637e0eb4c7da29e378cc7c5a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5844687bb2b21bc245a2c48650dbfa"><td class="memTemplParams" colspan="2"><a class="anchor" id="abe5844687bb2b21bc245a2c48650dbfa"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:abe5844687bb2b21bc245a2c48650dbfa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise&lt; and_ &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:abe5844687bb2b21bc245a2c48650dbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb9202bef1c9d60817bcf5648cd584f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1bb9202bef1c9d60817bcf5648cd584f"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a1bb9202bef1c9d60817bcf5648cd584f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise&lt; and_ &gt;, T_arg1, <br class="typebreak"/>
typename unwrap_reference<br class="typebreak"/>
&lt; T_arg2 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr class="separator:a1bb9202bef1c9d60817bcf5648cd584f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38659772ca6870a3cbd7db5f4133438"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae38659772ca6870a3cbd7db5f4133438"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:ae38659772ca6870a3cbd7db5f4133438"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise&lt; and_ &gt;, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg1 &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:ae38659772ca6870a3cbd7db5f4133438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada950dddd55b6900ebb976eb61deb67c"><td class="memTemplParams" colspan="2"><a class="anchor" id="ada950dddd55b6900ebb976eb61deb67c"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:ada950dddd55b6900ebb976eb61deb67c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise&lt; or_ &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:ada950dddd55b6900ebb976eb61deb67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a59dbc3bbd24222ca2a15d99f56756"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa1a59dbc3bbd24222ca2a15d99f56756"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:aa1a59dbc3bbd24222ca2a15d99f56756"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise&lt; or_ &gt;, T_arg1, <br class="typebreak"/>
typename unwrap_reference<br class="typebreak"/>
&lt; T_arg2 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr class="separator:aa1a59dbc3bbd24222ca2a15d99f56756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5979bc2e0fa05b0464c5d293441d451"><td class="memTemplParams" colspan="2"><a class="anchor" id="af5979bc2e0fa05b0464c5d293441d451"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:af5979bc2e0fa05b0464c5d293441d451"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise&lt; or_ &gt;, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg1 &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:af5979bc2e0fa05b0464c5d293441d451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa474bfa2e37216bb43e576018d48f9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6fa474bfa2e37216bb43e576018d48f9"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a6fa474bfa2e37216bb43e576018d48f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise&lt; xor_ &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator^</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a6fa474bfa2e37216bb43e576018d48f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f0b25213f4a5fc98d2fb2122e65963"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad6f0b25213f4a5fc98d2fb2122e65963"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:ad6f0b25213f4a5fc98d2fb2122e65963"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise&lt; xor_ &gt;, T_arg1, <br class="typebreak"/>
typename unwrap_reference<br class="typebreak"/>
&lt; T_arg2 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator^</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr class="separator:ad6f0b25213f4a5fc98d2fb2122e65963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89de0a3c206e9e2aa52ebc7ed2b42cc"><td class="memTemplParams" colspan="2"><a class="anchor" id="af89de0a3c206e9e2aa52ebc7ed2b42cc"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:af89de0a3c206e9e2aa52ebc7ed2b42cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise&lt; xor_ &gt;, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg1 &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator^</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:af89de0a3c206e9e2aa52ebc7ed2b42cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14c40bacb6ad99403a916583b2692c3"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab14c40bacb6ad99403a916583b2692c3"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:ab14c40bacb6ad99403a916583b2692c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;logical&lt; and_ &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;&amp;</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:ab14c40bacb6ad99403a916583b2692c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2558c01757cfd0dc7f55d009aa640df"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac2558c01757cfd0dc7f55d009aa640df"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:ac2558c01757cfd0dc7f55d009aa640df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;logical&lt; and_ &gt;, T_arg1, <br class="typebreak"/>
typename unwrap_reference<br class="typebreak"/>
&lt; T_arg2 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;&amp;</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr class="separator:ac2558c01757cfd0dc7f55d009aa640df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad95db7bcddbe6b66e4e1288de0be406"><td class="memTemplParams" colspan="2"><a class="anchor" id="aad95db7bcddbe6b66e4e1288de0be406"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:aad95db7bcddbe6b66e4e1288de0be406"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;logical&lt; and_ &gt;, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg1 &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;&amp;</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:aad95db7bcddbe6b66e4e1288de0be406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644177e972348dd4dc85d93e213655d3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a644177e972348dd4dc85d93e213655d3"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a644177e972348dd4dc85d93e213655d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;logical&lt; or_ &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator||</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a644177e972348dd4dc85d93e213655d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c3f65743475872f6b72eaab34e0540"><td class="memTemplParams" colspan="2"><a class="anchor" id="af3c3f65743475872f6b72eaab34e0540"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:af3c3f65743475872f6b72eaab34e0540"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;logical&lt; or_ &gt;, T_arg1, <br class="typebreak"/>
typename unwrap_reference<br class="typebreak"/>
&lt; T_arg2 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator||</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr class="separator:af3c3f65743475872f6b72eaab34e0540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69237ff83a236211c294f5fc536582e"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac69237ff83a236211c294f5fc536582e"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:ac69237ff83a236211c294f5fc536582e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;logical&lt; or_ &gt;, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg1 &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator||</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:ac69237ff83a236211c294f5fc536582e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690ddb5f264344feebbe769dd679d4df"><td class="memTemplParams" colspan="2"><a class="anchor" id="a690ddb5f264344feebbe769dd679d4df"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a690ddb5f264344feebbe769dd679d4df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; less &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a690ddb5f264344feebbe769dd679d4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1d62fc359b84f690e2feac53ae6d15"><td class="memTemplParams" colspan="2"><a class="anchor" id="aff1d62fc359b84f690e2feac53ae6d15"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:aff1d62fc359b84f690e2feac53ae6d15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; less &gt;, T_arg1, <br class="typebreak"/>
typename unwrap_reference<br class="typebreak"/>
&lt; T_arg2 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr class="separator:aff1d62fc359b84f690e2feac53ae6d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb219a2411a4be710407054099e19aa"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3eb219a2411a4be710407054099e19aa"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a3eb219a2411a4be710407054099e19aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; less &gt;, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg1 &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a3eb219a2411a4be710407054099e19aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ab52b5322acd79a509a21562871c91"><td class="memTemplParams" colspan="2"><a class="anchor" id="a52ab52b5322acd79a509a21562871c91"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a52ab52b5322acd79a509a21562871c91"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; greater &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a52ab52b5322acd79a509a21562871c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7398687b5297d41ceb3333a3afa0370d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7398687b5297d41ceb3333a3afa0370d"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a7398687b5297d41ceb3333a3afa0370d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; greater &gt;, T_arg1, <br class="typebreak"/>
typename unwrap_reference<br class="typebreak"/>
&lt; T_arg2 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr class="separator:a7398687b5297d41ceb3333a3afa0370d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218d50bcca425849337f0cfec8fda958"><td class="memTemplParams" colspan="2"><a class="anchor" id="a218d50bcca425849337f0cfec8fda958"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a218d50bcca425849337f0cfec8fda958"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; greater &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a218d50bcca425849337f0cfec8fda958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab172c6bb1767fd03e2220999aeec854e"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab172c6bb1767fd03e2220999aeec854e"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:ab172c6bb1767fd03e2220999aeec854e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; less_equal &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:ab172c6bb1767fd03e2220999aeec854e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97402578ec9ed2b4d8fe0121b756a4f0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a97402578ec9ed2b4d8fe0121b756a4f0"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a97402578ec9ed2b4d8fe0121b756a4f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; less_equal &gt;<br class="typebreak"/>
, T_arg1, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg2 &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr class="separator:a97402578ec9ed2b4d8fe0121b756a4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76432b61d8da0193e6a6e5ed5a4c6e7"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab76432b61d8da0193e6a6e5ed5a4c6e7"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:ab76432b61d8da0193e6a6e5ed5a4c6e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; less_equal &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:ab76432b61d8da0193e6a6e5ed5a4c6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891f09951c0008b115302409d3185610"><td class="memTemplParams" colspan="2"><a class="anchor" id="a891f09951c0008b115302409d3185610"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a891f09951c0008b115302409d3185610"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; greater_equal &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a891f09951c0008b115302409d3185610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0900659eeb151e54816c264890c797"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5c0900659eeb151e54816c264890c797"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a5c0900659eeb151e54816c264890c797"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; greater_equal &gt;<br class="typebreak"/>
, T_arg1, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg2 &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr class="separator:a5c0900659eeb151e54816c264890c797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072d58916d1df76b95e42794da79b46e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a072d58916d1df76b95e42794da79b46e"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a072d58916d1df76b95e42794da79b46e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; greater_equal &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a072d58916d1df76b95e42794da79b46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab729e9aaf896e54911491aa3092cc049"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab729e9aaf896e54911491aa3092cc049"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:ab729e9aaf896e54911491aa3092cc049"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; equal_to &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:ab729e9aaf896e54911491aa3092cc049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8445916bee9cb5a4a6a02d0c8808c0d7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8445916bee9cb5a4a6a02d0c8808c0d7"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a8445916bee9cb5a4a6a02d0c8808c0d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; equal_to &gt;<br class="typebreak"/>
, T_arg1, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg2 &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr class="separator:a8445916bee9cb5a4a6a02d0c8808c0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf69474f6dfa2892ce04b5880aef9718"><td class="memTemplParams" colspan="2"><a class="anchor" id="abf69474f6dfa2892ce04b5880aef9718"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:abf69474f6dfa2892ce04b5880aef9718"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; equal_to &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:abf69474f6dfa2892ce04b5880aef9718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0dafde3ae38a6efed954c79dfba264"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3a0dafde3ae38a6efed954c79dfba264"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a3a0dafde3ae38a6efed954c79dfba264"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; not_equal_to &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a3a0dafde3ae38a6efed954c79dfba264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f23426e80183eac99a1b60c2e24654"><td class="memTemplParams" colspan="2"><a class="anchor" id="a11f23426e80183eac99a1b60c2e24654"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a11f23426e80183eac99a1b60c2e24654"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; not_equal_to &gt;<br class="typebreak"/>
, T_arg1, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg2 &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr class="separator:a11f23426e80183eac99a1b60c2e24654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175a0e84f831ffa7f3c02af403b5807c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a175a0e84f831ffa7f3c02af403b5807c"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a175a0e84f831ffa7f3c02af403b5807c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;relational&lt; not_equal_to &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a175a0e84f831ffa7f3c02af403b5807c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa502d74870cb06b7fdc9480269dad276"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa502d74870cb06b7fdc9480269dad276"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:aa502d74870cb06b7fdc9480269dad276"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic_assign&lt; plus &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:aa502d74870cb06b7fdc9480269dad276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38757abe5c633f30554bab0dc0ecd10"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae38757abe5c633f30554bab0dc0ecd10"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:ae38757abe5c633f30554bab0dc0ecd10"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic_assign&lt; plus &gt;<br class="typebreak"/>
, T_arg1, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg2 &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr class="separator:ae38757abe5c633f30554bab0dc0ecd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd3d2107ce6d5001b3797434c6f20c3"><td class="memTemplParams" colspan="2"><a class="anchor" id="aafd3d2107ce6d5001b3797434c6f20c3"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:aafd3d2107ce6d5001b3797434c6f20c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic_assign&lt; plus &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:aafd3d2107ce6d5001b3797434c6f20c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42e7448034e53eeea789e5876e88ecb"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab42e7448034e53eeea789e5876e88ecb"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:ab42e7448034e53eeea789e5876e88ecb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic_assign&lt; minus &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:ab42e7448034e53eeea789e5876e88ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5d8c399c9fa835563a3e233b8f8dfb"><td class="memTemplParams" colspan="2"><a class="anchor" id="aae5d8c399c9fa835563a3e233b8f8dfb"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:aae5d8c399c9fa835563a3e233b8f8dfb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic_assign&lt; minus &gt;<br class="typebreak"/>
, T_arg1, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg2 &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr class="separator:aae5d8c399c9fa835563a3e233b8f8dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543214552d6aa98cf441205eaebcd0de"><td class="memTemplParams" colspan="2"><a class="anchor" id="a543214552d6aa98cf441205eaebcd0de"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a543214552d6aa98cf441205eaebcd0de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic_assign&lt; minus &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-=</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a543214552d6aa98cf441205eaebcd0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695b17d39b1ddad114edd308759e8903"><td class="memTemplParams" colspan="2"><a class="anchor" id="a695b17d39b1ddad114edd308759e8903"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a695b17d39b1ddad114edd308759e8903"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic_assign&lt; multiplies &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a695b17d39b1ddad114edd308759e8903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e51d4663ca63d81d3e8385e4daa5d81"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8e51d4663ca63d81d3e8385e4daa5d81"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a8e51d4663ca63d81d3e8385e4daa5d81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic_assign&lt; multiplies &gt;<br class="typebreak"/>
, T_arg1, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg2 &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr class="separator:a8e51d4663ca63d81d3e8385e4daa5d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ecaa8d2e8f731c3e2690bf811000448"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4ecaa8d2e8f731c3e2690bf811000448"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a4ecaa8d2e8f731c3e2690bf811000448"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic_assign&lt; multiplies &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*=</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a4ecaa8d2e8f731c3e2690bf811000448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0684430bc6cab3edf5c75627ebde19bb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0684430bc6cab3edf5c75627ebde19bb"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a0684430bc6cab3edf5c75627ebde19bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic_assign&lt; divides &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a0684430bc6cab3edf5c75627ebde19bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d308359f46bd76c69a7cd5923ff41c"><td class="memTemplParams" colspan="2"><a class="anchor" id="af4d308359f46bd76c69a7cd5923ff41c"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:af4d308359f46bd76c69a7cd5923ff41c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic_assign&lt; divides &gt;<br class="typebreak"/>
, T_arg1, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg2 &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr class="separator:af4d308359f46bd76c69a7cd5923ff41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f743a17797f98a6ab48a69e1b08529"><td class="memTemplParams" colspan="2"><a class="anchor" id="a92f743a17797f98a6ab48a69e1b08529"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a92f743a17797f98a6ab48a69e1b08529"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic_assign&lt; divides &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/=</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a92f743a17797f98a6ab48a69e1b08529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2b9ee14998bac3458ea717bd9a5493"><td class="memTemplParams" colspan="2"><a class="anchor" id="aec2b9ee14998bac3458ea717bd9a5493"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:aec2b9ee14998bac3458ea717bd9a5493"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic_assign&lt; modulus &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator%=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:aec2b9ee14998bac3458ea717bd9a5493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e774f94583a5c3b39421110112145c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a00e774f94583a5c3b39421110112145c"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a00e774f94583a5c3b39421110112145c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic_assign&lt; modulus &gt;<br class="typebreak"/>
, T_arg1, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg2 &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator%=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr class="separator:a00e774f94583a5c3b39421110112145c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7e13a4cdaba87291a71b14bf02c9f7"><td class="memTemplParams" colspan="2"><a class="anchor" id="aef7e13a4cdaba87291a71b14bf02c9f7"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:aef7e13a4cdaba87291a71b14bf02c9f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;arithmetic_assign&lt; modulus &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator%=</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:aef7e13a4cdaba87291a71b14bf02c9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997b45243eeb4c72e314829f82725c95"><td class="memTemplParams" colspan="2"><a class="anchor" id="a997b45243eeb4c72e314829f82725c95"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a997b45243eeb4c72e314829f82725c95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise_assign&lt; leftshift &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a997b45243eeb4c72e314829f82725c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036aa37d9a91c89700f9e150a9e6e976"><td class="memTemplParams" colspan="2"><a class="anchor" id="a036aa37d9a91c89700f9e150a9e6e976"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a036aa37d9a91c89700f9e150a9e6e976"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise_assign&lt; leftshift &gt;<br class="typebreak"/>
, T_arg1, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg2 &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr class="separator:a036aa37d9a91c89700f9e150a9e6e976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59346cbe1429818a012e5ddb27d44b7e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a59346cbe1429818a012e5ddb27d44b7e"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a59346cbe1429818a012e5ddb27d44b7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise_assign&lt; leftshift &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;=</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a59346cbe1429818a012e5ddb27d44b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75036492841656f06681d2202ede94b4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a75036492841656f06681d2202ede94b4"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a75036492841656f06681d2202ede94b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise_assign&lt; rightshift &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a75036492841656f06681d2202ede94b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91959b173d551c7d0faa600fc549cfc1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a91959b173d551c7d0faa600fc549cfc1"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a91959b173d551c7d0faa600fc549cfc1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise_assign&lt; rightshift &gt;<br class="typebreak"/>
, T_arg1, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg2 &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr class="separator:a91959b173d551c7d0faa600fc549cfc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0fe925f5ca3bec86624f944fe380a0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9c0fe925f5ca3bec86624f944fe380a0"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a9c0fe925f5ca3bec86624f944fe380a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise_assign&lt; rightshift &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;=</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a9c0fe925f5ca3bec86624f944fe380a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640f479b5021cbb9b8b4981a9a26b5e2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a640f479b5021cbb9b8b4981a9a26b5e2"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a640f479b5021cbb9b8b4981a9a26b5e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise_assign&lt; and_ &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a640f479b5021cbb9b8b4981a9a26b5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d37badb49bc32824d232a7ec3d456d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a59d37badb49bc32824d232a7ec3d456d"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a59d37badb49bc32824d232a7ec3d456d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise_assign&lt; and_ &gt;<br class="typebreak"/>
, T_arg1, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg2 &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr class="separator:a59d37badb49bc32824d232a7ec3d456d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c47e3f4cdb207d6939e3f641619de4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a27c47e3f4cdb207d6939e3f641619de4"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a27c47e3f4cdb207d6939e3f641619de4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise_assign&lt; and_ &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;=</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a27c47e3f4cdb207d6939e3f641619de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeca5bf2c58770a32f8991ff75ff2ef5"><td class="memTemplParams" colspan="2"><a class="anchor" id="aeeca5bf2c58770a32f8991ff75ff2ef5"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:aeeca5bf2c58770a32f8991ff75ff2ef5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise_assign&lt; or_ &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:aeeca5bf2c58770a32f8991ff75ff2ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9601fec9fbcc27607eff46ec8e121172"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9601fec9fbcc27607eff46ec8e121172"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a9601fec9fbcc27607eff46ec8e121172"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise_assign&lt; or_ &gt;, T_arg1, <br class="typebreak"/>
typename unwrap_reference<br class="typebreak"/>
&lt; T_arg2 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr class="separator:a9601fec9fbcc27607eff46ec8e121172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec125c1b18e9db19202664d4853f5c0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0ec125c1b18e9db19202664d4853f5c0"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a0ec125c1b18e9db19202664d4853f5c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise_assign&lt; or_ &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|=</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a0ec125c1b18e9db19202664d4853f5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a0040229fcfeac06627a3d28722c67"><td class="memTemplParams" colspan="2"><a class="anchor" id="a65a0040229fcfeac06627a3d28722c67"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a65a0040229fcfeac06627a3d28722c67"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise_assign&lt; xor_ &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator^=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a65a0040229fcfeac06627a3d28722c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1195e9ec2037b3ecdf9a5c08f04ba6fd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1195e9ec2037b3ecdf9a5c08f04ba6fd"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a1195e9ec2037b3ecdf9a5c08f04ba6fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise_assign&lt; xor_ &gt;<br class="typebreak"/>
, T_arg1, typename <br class="typebreak"/>
unwrap_reference&lt; T_arg2 &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator^=</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const T_arg2&amp; a2)</td></tr>
<tr class="separator:a1195e9ec2037b3ecdf9a5c08f04ba6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892af6543e23b5bcbbbebcde500bf398"><td class="memTemplParams" colspan="2"><a class="anchor" id="a892af6543e23b5bcbbbebcde500bf398"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:a892af6543e23b5bcbbbebcde500bf398"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator<br class="typebreak"/>
&lt;bitwise_assign&lt; xor_ &gt;<br class="typebreak"/>
, typename unwrap_reference<br class="typebreak"/>
&lt; T_arg1 &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator^=</b> (const T_arg1&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:a892af6543e23b5bcbbbebcde500bf398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb249627ddbc2ab96fb53ca37548f5e3"><td class="memTemplParams" colspan="2"><a class="anchor" id="adb249627ddbc2ab96fb53ca37548f5e3"></a>
template &lt;class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:adb249627ddbc2ab96fb53ca37548f5e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator&lt;comma, <br class="typebreak"/>
T_arg1, T_arg2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator,</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg1 &gt;&amp; a1, const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg2 &gt;&amp; a2)</td></tr>
<tr class="separator:adb249627ddbc2ab96fb53ca37548f5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12f80b1e74a1ac7188942c2d63e9391"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac12f80b1e74a1ac7188942c2d63e9391"></a>
template &lt;class T_arg &gt; </td></tr>
<tr class="memitem:ac12f80b1e74a1ac7188942c2d63e9391"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator_unary<br class="typebreak"/>
&lt; unary_arithmetic<br class="typebreak"/>
&lt; pre_increment &gt;, T_arg &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator++</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg &gt;&amp; a)</td></tr>
<tr class="separator:ac12f80b1e74a1ac7188942c2d63e9391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362c2defba5d52e3c08e82e44210fd7d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a362c2defba5d52e3c08e82e44210fd7d"></a>
template &lt;class T_arg &gt; </td></tr>
<tr class="memitem:a362c2defba5d52e3c08e82e44210fd7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator_unary<br class="typebreak"/>
&lt; unary_arithmetic<br class="typebreak"/>
&lt; pre_decrement &gt;, T_arg &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator--</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg &gt;&amp; a)</td></tr>
<tr class="separator:a362c2defba5d52e3c08e82e44210fd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446ff360e9b068629c36f5bb89b08509"><td class="memTemplParams" colspan="2"><a class="anchor" id="a446ff360e9b068629c36f5bb89b08509"></a>
template &lt;class T_arg &gt; </td></tr>
<tr class="memitem:a446ff360e9b068629c36f5bb89b08509"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator_unary<br class="typebreak"/>
&lt; unary_arithmetic&lt; negate &gt;<br class="typebreak"/>
, T_arg &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg &gt;&amp; a)</td></tr>
<tr class="separator:a446ff360e9b068629c36f5bb89b08509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af545fda3255dae773a89360f82c391c5"><td class="memTemplParams" colspan="2"><a class="anchor" id="af545fda3255dae773a89360f82c391c5"></a>
template &lt;class T_arg &gt; </td></tr>
<tr class="memitem:af545fda3255dae773a89360f82c391c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator_unary<br class="typebreak"/>
&lt; unary_bitwise&lt; not_ &gt;, T_arg &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator~</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg &gt;&amp; a)</td></tr>
<tr class="separator:af545fda3255dae773a89360f82c391c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4b1cb283951e310a767b444338bbae"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2c4b1cb283951e310a767b444338bbae"></a>
template &lt;class T_arg &gt; </td></tr>
<tr class="memitem:a2c4b1cb283951e310a767b444338bbae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator_unary<br class="typebreak"/>
&lt; unary_logical&lt; not_ &gt;, T_arg &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg &gt;&amp; a)</td></tr>
<tr class="separator:a2c4b1cb283951e310a767b444338bbae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c64722e1648b6f418f13776b73a025a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3c64722e1648b6f418f13776b73a025a"></a>
template &lt;class T_arg &gt; </td></tr>
<tr class="memitem:a3c64722e1648b6f418f13776b73a025a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator_unary<br class="typebreak"/>
&lt; unary_other&lt; address &gt;<br class="typebreak"/>
, T_arg &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg &gt;&amp; a)</td></tr>
<tr class="separator:a3c64722e1648b6f418f13776b73a025a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8d8ab910a0ee91ce2e59657882a9a9"><td class="memTemplParams" colspan="2"><a class="anchor" id="adf8d8ab910a0ee91ce2e59657882a9a9"></a>
template &lt;class T_arg &gt; </td></tr>
<tr class="memitem:adf8d8ab910a0ee91ce2e59657882a9a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_operator_unary<br class="typebreak"/>
&lt; unary_other&lt; dereference &gt;<br class="typebreak"/>
, T_arg &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_arg &gt;&amp; a)</td></tr>
<tr class="separator:adf8d8ab910a0ee91ce2e59657882a9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3dfacf152109acf63a56c6af23e9ed3"><td class="memTemplParams" colspan="2"><a class="anchor" id="af3dfacf152109acf63a56c6af23e9ed3"></a>
template &lt;class T_type , class T_arg &gt; </td></tr>
<tr class="memitem:af3dfacf152109acf63a56c6af23e9ed3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a><br class="typebreak"/>
&lt; lambda_operator_convert<br class="typebreak"/>
&lt; cast_&lt; reinterpret_ &gt;<br class="typebreak"/>
, T_type, typename <br class="typebreak"/>
<a class="el" href="structsigc_1_1unwrap__lambda__type.html">unwrap_lambda_type</a>&lt; T_arg &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reinterpret_cast_</b> (const T_arg &amp;a)</td></tr>
<tr class="separator:af3dfacf152109acf63a56c6af23e9ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62818bb17ce79137cc77b61fd6390561"><td class="memTemplParams" colspan="2"><a class="anchor" id="a62818bb17ce79137cc77b61fd6390561"></a>
template &lt;class T_type , class T_arg &gt; </td></tr>
<tr class="memitem:a62818bb17ce79137cc77b61fd6390561"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a><br class="typebreak"/>
&lt; lambda_operator_convert<br class="typebreak"/>
&lt; cast_&lt; static_ &gt;, T_type, <br class="typebreak"/>
typename <a class="el" href="structsigc_1_1unwrap__lambda__type.html">unwrap_lambda_type</a><br class="typebreak"/>
&lt; T_arg &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>static_cast_</b> (const T_arg &amp;a)</td></tr>
<tr class="separator:a62818bb17ce79137cc77b61fd6390561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202f49c5f6f3c8b87bfec640ae3b2927"><td class="memTemplParams" colspan="2"><a class="anchor" id="a202f49c5f6f3c8b87bfec640ae3b2927"></a>
template &lt;class T_type , class T_arg &gt; </td></tr>
<tr class="memitem:a202f49c5f6f3c8b87bfec640ae3b2927"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a><br class="typebreak"/>
&lt; lambda_operator_convert<br class="typebreak"/>
&lt; cast_&lt; dynamic_ &gt;, T_type, <br class="typebreak"/>
typename <a class="el" href="structsigc_1_1unwrap__lambda__type.html">unwrap_lambda_type</a><br class="typebreak"/>
&lt; T_arg &gt;::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dynamic_cast_</b> (const T_arg &amp;a)</td></tr>
<tr class="separator:a202f49c5f6f3c8b87bfec640ae3b2927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f775511ed1116ba6ec5617df8612ca"><td class="memTemplParams" colspan="2"><a class="anchor" id="a84f775511ed1116ba6ec5617df8612ca"></a>
template &lt;class T_action , class T_functor , class T_type1 &gt; </td></tr>
<tr class="memitem:a84f775511ed1116ba6ec5617df8612ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>visit_each</b> (const T_action &amp;_A_action, const lambda_group1&lt; T_functor, T_type1 &gt; &amp;_A_target)</td></tr>
<tr class="separator:a84f775511ed1116ba6ec5617df8612ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c4539902914f77a66943a4d4f721ec"><td class="memTemplParams" colspan="2"><a class="anchor" id="a49c4539902914f77a66943a4d4f721ec"></a>
template &lt;class T_action , class T_functor , class T_type1 , class T_type2 &gt; </td></tr>
<tr class="memitem:a49c4539902914f77a66943a4d4f721ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>visit_each</b> (const T_action &amp;_A_action, const lambda_group2&lt; T_functor, T_type1, T_type2 &gt; &amp;_A_target)</td></tr>
<tr class="separator:a49c4539902914f77a66943a4d4f721ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5db54ada45b06dee02edbdb977dc62b"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa5db54ada45b06dee02edbdb977dc62b"></a>
template &lt;class T_action , class T_functor , class T_type1 , class T_type2 , class T_type3 &gt; </td></tr>
<tr class="memitem:aa5db54ada45b06dee02edbdb977dc62b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>visit_each</b> (const T_action &amp;_A_action, const lambda_group3&lt; T_functor, T_type1, T_type2, T_type3 &gt; &amp;_A_target)</td></tr>
<tr class="separator:aa5db54ada45b06dee02edbdb977dc62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a5905d189af5fab33d8c456f097a29"><td class="memTemplParams" colspan="2"><a class="anchor" id="a56a5905d189af5fab33d8c456f097a29"></a>
template &lt;class T_functor , class T_type1 &gt; </td></tr>
<tr class="memitem:a56a5905d189af5fab33d8c456f097a29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_group1<br class="typebreak"/>
&lt; T_functor, typename <br class="typebreak"/>
unwrap_reference&lt; T_type1 &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>group</b> (const T_functor &amp;_A_func, T_type1 _A_1)</td></tr>
<tr class="separator:a56a5905d189af5fab33d8c456f097a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbc8eaf9aa10213c228b53e69f3fead"><td class="memTemplParams" colspan="2"><a class="anchor" id="aadbc8eaf9aa10213c228b53e69f3fead"></a>
template &lt;class T_functor , class T_type1 , class T_type2 &gt; </td></tr>
<tr class="memitem:aadbc8eaf9aa10213c228b53e69f3fead"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_group2<br class="typebreak"/>
&lt; T_functor, typename <br class="typebreak"/>
unwrap_reference&lt; T_type1 &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, typename <br class="typebreak"/>
unwrap_reference&lt; T_type2 &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>group</b> (const T_functor &amp;_A_func, T_type1 _A_1, T_type2 _A_2)</td></tr>
<tr class="separator:aadbc8eaf9aa10213c228b53e69f3fead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993b22c0e13eb536edd9bcc3afd6d949"><td class="memTemplParams" colspan="2"><a class="anchor" id="a993b22c0e13eb536edd9bcc3afd6d949"></a>
template &lt;class T_functor , class T_type1 , class T_type2 , class T_type3 &gt; </td></tr>
<tr class="memitem:a993b22c0e13eb536edd9bcc3afd6d949"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; lambda_group3<br class="typebreak"/>
&lt; T_functor, typename <br class="typebreak"/>
unwrap_reference&lt; T_type1 &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, typename <br class="typebreak"/>
unwrap_reference&lt; T_type2 &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a>, typename <br class="typebreak"/>
unwrap_reference&lt; T_type3 &gt;<br class="typebreak"/>
::<a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga2c2933c16c723af4d77eb939438617ca">type</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>group</b> (const T_functor &amp;_A_func, T_type1 _A_1, T_type2 _A_2, T_type3 _A_3)</td></tr>
<tr class="separator:a993b22c0e13eb536edd9bcc3afd6d949"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The libsigc++ namespace. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a48e982c74c057b5630246ba436524041"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1reference__wrapper.html">reference_wrapper</a>&lt;T_type&gt; sigc::ref </td>
          <td>(</td>
          <td class="paramtype">T_type &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a reference wrapper. </p>
<p>Passing an object throught <a class="el" href="namespacesigc.html#a48e982c74c057b5630246ba436524041" title="Creates a reference wrapper.">sigc::ref()</a> makes libsigc++ adaptors like, e.g., <a class="el" href="group__bind.html#ga2f099bc6056b32f2a58134ba8537c6f4" title="Creates an adaptor of type sigc::bind_functor which binds the passed argument to the passed functor...">sigc::bind</a> store references to the object instead of copies. If the object type inherits from <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection.">sigc::trackable</a> this will ensure automatic invalidation of the adaptors when the object is deleted or overwritten.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Reference to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference wrapper. </dd></dl>

</div>
</div>
<a class="anchor" id="a670882bd3fa5890b464871ac515aaba9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1const__reference__wrapper.html">const_reference_wrapper</a>&lt;T_type&gt; sigc::ref </td>
          <td>(</td>
          <td class="paramtype">const T_type &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a const reference wrapper. </p>
<p>Passing an object throught <a class="el" href="namespacesigc.html#a48e982c74c057b5630246ba436524041" title="Creates a reference wrapper.">sigc::ref()</a> makes libsigc++ adaptors like, e.g., <a class="el" href="group__bind.html#ga2f099bc6056b32f2a58134ba8537c6f4" title="Creates an adaptor of type sigc::bind_functor which binds the passed argument to the passed functor...">sigc::bind</a> store references to the object instead of copies. If the object type inherits from <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection.">sigc::trackable</a> this will ensure automatic invalidation of the adaptors when the object is deleted or overwritten.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Reference to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference wrapper. </dd></dl>

</div>
</div>
<a class="anchor" id="a5fbbd890bbed369b5a77ef375a34ab47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T_type&amp; sigc::unwrap_lambda_value </td>
          <td>(</td>
          <td class="paramtype">T_type &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the object stored inside a lambda object. </p>
<p>Returns the object passed as argument, if it is not of type lambda. </p>

</div>
</div>
<a class="anchor" id="a8e560e6113af0c1e9f462471c1d502d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt;T_type&amp;&gt; sigc::var </td>
          <td>(</td>
          <td class="paramtype">T_type &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a reference into a lambda object. </p>
<p><a class="el" href="namespacesigc.html#a8e560e6113af0c1e9f462471c1d502d4" title="Converts a reference into a lambda object.">sigc::var</a> creates a 0-ary functor, returning the value of a referenced variable.</p>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordtype">int</span> data;</div>
<div class="line"> <a class="code" href="classsigc_1_1signal.html" title="Convenience wrapper for the numbered sigc::signal# templates.">sigc::signal&lt;int&gt;</a> readValue;</div>
<div class="line"></div>
<div class="line"> readValue.<a class="code" href="classsigc_1_1signal7.html#adc55ac9b0f935fd87a67904022e03cb2" title="Add a slot to the list of slots.">connect</a>(<a class="code" href="namespacesigc.html#a8e560e6113af0c1e9f462471c1d502d4" title="Converts a reference into a lambda object.">sigc::var</a>(data));</div>
<div class="line"></div>
<div class="line"> data = 3;</div>
<div class="line"> <a class="codeRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01608.html#aaf93fdf0812752e0e02c501dea1b38f0">std::cout</a> &lt;&lt; readValue() &lt;&lt; <a class="codeRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01608.html#a8b3758bb8f17c440c7963363f42f69f3">std::endl</a>; <span class="comment">//Prints 3.</span></div>
<div class="line"></div>
<div class="line"> data = 5;</div>
<div class="line"> <a class="codeRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01608.html#aaf93fdf0812752e0e02c501dea1b38f0">std::cout</a> &lt;&lt; readValue() &lt;&lt; <a class="codeRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01608.html#a8b3758bb8f17c440c7963363f42f69f3">std::endl</a>; <span class="comment">//Prints 5.</span></div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<p>If your compiler supports C++11 lambda expressions, and you use the macro <a class="el" href="group__sigcfunctors.html#gadf1ba3cacb09cc5c3c3e399836ec6e50" title="Helper macro, if you want to mix user-defined and third party functors with libsigc++.">SIGC_FUNCTORS_DEDUCE_RESULT_TYPE_WITH_DECLTYPE</a>, you can replace </p>
<div class="fragment"><div class="line">readValue.<a class="code" href="classsigc_1_1signal7.html#adc55ac9b0f935fd87a67904022e03cb2" title="Add a slot to the list of slots.">connect</a>(<a class="code" href="namespacesigc.html#a8e560e6113af0c1e9f462471c1d502d4" title="Converts a reference into a lambda object.">sigc::var</a>(data));</div>
</div><!-- fragment --><p> in the example by </p>
<div class="fragment"><div class="line">readValue.<a class="code" href="classsigc_1_1signal7.html#adc55ac9b0f935fd87a67904022e03cb2" title="Add a slot to the list of slots.">connect</a>([&amp;data] () -&gt; <span class="keywordtype">int</span> { <span class="keywordflow">return</span> data; });</div>
</div><!-- fragment --> </div>
</div>
<a class="anchor" id="a950519b7b414c384d808a4db9eefbd50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_type , bool I_derives_trackable&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const limit_reference&lt; T_type, I_derives_trackable &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of <a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> specialized for the <a class="el" href="classsigc_1_1limit__reference.html" title="A limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from sig...">limit_reference</a> class, to call <a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> on the entity returned by the <a class="el" href="classsigc_1_1limit__reference.html" title="A limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from sig...">limit_reference</a>'s visit() method. </p>
<ul>
<li><em>T_action</em> The type of functor to invoke.</li>
<li><em>T_type</em> The type of the reference. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_action</td><td>The functor to invoke. </td></tr>
    <tr><td class="paramname">_A_argument</td><td>The visited instance. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a5c399fa8208f9afd4793891f3656fb86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bound_argument&lt; T_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_argument</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of <a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> specialized for the <a class="el" href="classsigc_1_1bound__argument.html" title="A bound_argument&lt;Foo&gt; object stores a bound (for instance, with sigc::bind(), or sigc::bind_return())...">bound_argument</a> class. </p>
<p>Call <a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> on the entity returned by the <a class="el" href="classsigc_1_1bound__argument.html" title="A bound_argument&lt;Foo&gt; object stores a bound (for instance, with sigc::bind(), or sigc::bind_return())...">bound_argument</a>'s visit() method. <em>T_action</em> The type of functor to invoke. <em>T_type</em> The type of <a class="el" href="classsigc_1_1bound__argument.html" title="A bound_argument&lt;Foo&gt; object stores a bound (for instance, with sigc::bind(), or sigc::bind_return())...">bound_argument</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_action</td><td>The functor to invoke. </td></tr>
    <tr><td class="paramname">_A_argument</td><td>The visited instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1deae338d4ae5fb2e9a49e6bffb31760"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_type , bool I_derives_trackable&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const const_limit_reference&lt; T_type, I_derives_trackable &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of <a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> specialized for the <a class="el" href="classsigc_1_1const__limit__reference.html" title="A const_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from sigc::trackable, then visit_each&lt;&gt;() will &quot;limit&quot; itself to the sigc::trackable reference instead of the derived reference.">const_limit_reference</a> class, to call <a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> on the entity returned by the <a class="el" href="classsigc_1_1const__limit__reference.html" title="A const_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from sigc::trackable, then visit_each&lt;&gt;() will &quot;limit&quot; itself to the sigc::trackable reference instead of the derived reference.">const_limit_reference</a>'s visit() method. </p>
<ul>
<li><em>T_action</em> The type of functor to invoke.</li>
<li><em>T_type</em> The type of the reference. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_action</td><td>The functor to invoke. </td></tr>
    <tr><td class="paramname">_A_argument</td><td>The visited instance. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a2755fccba2c42f1613ed81c6477f8f8c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_type , bool I_derives_trackable&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile_limit_reference&lt; T_type, I_derives_trackable &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of <a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> specialized for the <a class="el" href="classsigc_1_1volatile__limit__reference.html" title="A volatile_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from sigc::trackable, then visit_each&lt;&gt;() will &quot;limit&quot; itself to the sigc::trackable reference instead of the derived reference.">volatile_limit_reference</a> class, to call <a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> on the entity returned by the <a class="el" href="classsigc_1_1volatile__limit__reference.html" title="A volatile_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from sigc::trackable, then visit_each&lt;&gt;() will &quot;limit&quot; itself to the sigc::trackable reference instead of the derived reference.">volatile_limit_reference</a>'s visit() method. </p>
<ul>
<li><em>T_action</em> The type of functor to invoke.</li>
<li><em>T_type</em> The type of the reference. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_action</td><td>The functor to invoke. </td></tr>
    <tr><td class="paramname">_A_argument</td><td>The visited instance. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a335eb8de8833544f16cf12875f88d934"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_action , class T_type , bool I_derives_trackable&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sigc::visit_each </td>
          <td>(</td>
          <td class="paramtype">const T_action &amp;&#160;</td>
          <td class="paramname"><em>_A_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const const_volatile_limit_reference&lt; T_type, I_derives_trackable &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of <a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> specialized for the <a class="el" href="classsigc_1_1const__volatile__limit__reference.html" title="A const_volatile_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that...">const_volatile_limit_reference</a> class, to call <a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404" title="This function performs a functor on each of the targets of a functor.">visit_each()</a> on the entity returned by the <a class="el" href="classsigc_1_1const__volatile__limit__reference.html" title="A const_volatile_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that...">const_volatile_limit_reference</a>'s visit() method. </p>
<ul>
<li><em>T_action</em> The type of functor to invoke.</li>
<li><em>T_type</em> The type of the reference. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_action</td><td>The functor to invoke. </td></tr>
    <tr><td class="paramname">_A_argument</td><td>The visited instance. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Oct 18 2012 09:28:24 for libsigc++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
